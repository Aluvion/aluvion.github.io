

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/css/images/bg/favicon.ico">
  <link rel="icon" href="/css/images/bg/favicon.ico">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Aluvion">
  <meta name="keywords" content="">
  
    <meta name="description" content="前言读了读编译原理，用一句简单的 Python 代码来理一遍 Python 的编译执行过程。 因为 Python 不像 PHP 那样使用了 re2c 和 Bison 那些工具进行编译，所以看起来要麻烦很多。">
<meta property="og:type" content="article">
<meta property="og:title" content="Python从编译到执行">
<meta property="og:url" content="http://yoursite.com/2020/06/16/Python%E4%BB%8E%E7%BC%96%E8%AF%91%E5%88%B0%E6%89%A7%E8%A1%8C/index.html">
<meta property="og:site_name" content="Twings">
<meta property="og:description" content="前言读了读编译原理，用一句简单的 Python 代码来理一遍 Python 的编译执行过程。 因为 Python 不像 PHP 那样使用了 re2c 和 Bison 那些工具进行编译，所以看起来要麻烦很多。">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2020-06-16T09:00:00.000Z">
<meta property="article:modified_time" content="2022-04-15T13:47:37.878Z">
<meta property="article:author" content="Aluvion">
<meta property="article:tag" content="Web">
<meta property="article:tag" content="Python">
<meta name="twitter:card" content="summary_large_image">
  
  
  
  <title>Python从编译到执行 - Twings</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"yoursite.com","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 7.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Fluid</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/css/images/bg/bg5.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="Python从编译到执行"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2020-06-16 17:00" pubdate>
          2020年6月16日 下午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          6.6k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          55 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">Python从编译到执行</h1>
            
            
              <div class="markdown-body">
                
                <h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>读了读编译原理，用一句简单的 Python 代码来理一遍 Python 的编译执行过程。</p>
<p>因为 Python 不像 PHP 那样使用了 re2c 和 Bison 那些工具进行编译，所以看起来要麻烦很多。</p>
<span id="more"></span>

<hr>
<h3 id="调试环境"><a href="#调试环境" class="headerlink" title="调试环境"></a>调试环境</h3><p>源码下载地址：<a href="https://github.com/python/cpython/tree/2.7">https://github.com/python/cpython/tree/2.7</a></p>
<p>编译安装跟 PHP 差不多，就不说了。</p>
<p>测试脚本：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>研究语法分析的时候可以将 print 改成 prin 来观察分析过程，加上 -d 参数运行可以看到它的语法分析过程。</p>
<h3 id="入口"><a href="#入口" class="headerlink" title="入口"></a>入口</h3><p>Py_Main(main.c) -&gt; PyRun_AnyFileExFlags(pythonrun.c) -&gt; PyRun_SimpleFileExFlags(pythonrun.c) -&gt; PyRun_FileExFlags(pythonrun.c)</p>
<p>PyRun_FileExFlags 中将编译执行分为两个部分来进行：</p>
<ol>
<li>调用 PyParser_ASTFromFile 词法分析、语法分析生成 AST 树，解析 AST 树生成中间数据</li>
<li>调用 run_mod 解析数据生成 PyCodeObject(里面包括字节码等执行数据)，再执行字节码。</li>
</ol>
<p>我们从 PyParser_ASTFromFile 往下看，经过 PyParser_ParseFileFlagsEx 会来到 parsetok 函数，这里就是语法分析的部分了。</p>
<h3 id="词法分析"><a href="#词法分析" class="headerlink" title="词法分析"></a>词法分析</h3><p>语法分析是一个死循环，不停地调用 PyTokenizer_Get 从源码中读取 token 进行语法分析，PyTokenizer_Get 函数 则会调用 tok_get 函数，这个函数里面的就是主要的词法分析逻辑，因为代码很长所以就不全贴了。</p>
<p>词法分析相关的数据(按行存放的源码、指向下一个要分析字符的指针等等)都存放在 tok 中，这是一个 tok_state 结构体：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Tokenizer state */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tok_state</span> &#123;</span></span><br><span class="line">    <span class="comment">/* Input state; buf &lt;= cur &lt;= inp &lt;= end */</span></span><br><span class="line">    <span class="comment">/* NB an entire line is held in the buffer */</span></span><br><span class="line">    <span class="type">char</span> *buf;          <span class="comment">/* Input buffer, or NULL; malloc&#x27;ed if fp != NULL */</span></span><br><span class="line">    <span class="type">char</span> *cur;          <span class="comment">/* Next character in buffer */</span></span><br><span class="line">    <span class="type">char</span> *inp;          <span class="comment">/* End of data in buffer */</span></span><br><span class="line">    <span class="type">char</span> *end;          <span class="comment">/* End of input buffer if buf != NULL */</span></span><br><span class="line">    <span class="type">char</span> *start;        <span class="comment">/* Start of current token if not NULL */</span></span><br><span class="line">    <span class="type">int</span> done;           <span class="comment">/* E_OK normally, E_EOF at EOF, otherwise error code */</span></span><br><span class="line">    <span class="comment">/* NB If done != E_OK, cur must be == inp!!! */</span></span><br><span class="line">    FILE *fp;           <span class="comment">/* Rest of input; NULL if tokenizing a string */</span></span><br><span class="line">    <span class="type">int</span> tabsize;        <span class="comment">/* Tab spacing */</span></span><br><span class="line">    <span class="type">int</span> indent;         <span class="comment">/* Current indentation index */</span></span><br><span class="line">    <span class="type">int</span> indstack[MAXINDENT];            <span class="comment">/* Stack of indents */</span></span><br><span class="line">    <span class="type">int</span> atbol;          <span class="comment">/* Nonzero if at begin of new line */</span></span><br><span class="line">    <span class="type">int</span> pendin;         <span class="comment">/* Pending indents (if &gt; 0) or dedents (if &lt; 0) */</span></span><br><span class="line">    <span class="type">char</span> *prompt, *nextprompt;          <span class="comment">/* For interactive prompting */</span></span><br><span class="line">    <span class="type">int</span> lineno;         <span class="comment">/* Current line number */</span></span><br><span class="line">    <span class="type">int</span> level;          <span class="comment">/* () [] &#123;&#125; Parentheses nesting level */</span></span><br><span class="line">            <span class="comment">/* Used to allow free continuations inside them */</span></span><br><span class="line">    <span class="comment">/* Stuff for checking on different tab sizes */</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *filename;       <span class="comment">/* For error messages */</span></span><br><span class="line">    <span class="type">int</span> altwarning;     <span class="comment">/* Issue warning if alternate tabs don&#x27;t match */</span></span><br><span class="line">    <span class="type">int</span> alterror;       <span class="comment">/* Issue error if alternate tabs don&#x27;t match */</span></span><br><span class="line">    <span class="type">int</span> alttabsize;     <span class="comment">/* Alternate tab spacing */</span></span><br><span class="line">    <span class="type">int</span> altindstack[MAXINDENT];         <span class="comment">/* Stack of alternate indents */</span></span><br><span class="line">    <span class="comment">/* Stuff for PEP 0263 */</span></span><br><span class="line">    <span class="type">int</span> decoding_state;         <span class="comment">/* -1:decoding, 0:init, 1:raw */</span></span><br><span class="line">    <span class="type">int</span> decoding_erred;         <span class="comment">/* whether erred in decoding  */</span></span><br><span class="line">    <span class="type">int</span> read_coding_spec;       <span class="comment">/* whether &#x27;coding:...&#x27; has been read  */</span></span><br><span class="line">    <span class="type">char</span> *encoding;</span><br><span class="line">    <span class="type">int</span> cont_line;          <span class="comment">/* whether we are in a continuation line. */</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* line_start;     <span class="comment">/* pointer to start of current line */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> PGEN</span></span><br><span class="line">    PyObject *decoding_readline; <span class="comment">/* codecs.open(...).readline */</span></span><br><span class="line">    PyObject *decoding_buffer;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* enc;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* str;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* input; <span class="comment">/* Tokenizer&#x27;s newline translated copy of the string. */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>成员的用途在注释里都标注得很清楚了，源码在 tok 中是按行存放的，tok_get 函数每次调用 tok_nextc 从中取出一个字符进行分析。而在第一次进入 tok_get 函数的时候，tok 里面是没有源码的，在调用 tok_nextc 的时候会调用 decoding_fgets 读入一行源码。tok_nextc 函数除了读入源码和返回字符还有一些其他的操作，不过与本文主题不太相关所以不提。</p>
<p>在处理每行开头的时候会跳过空白字符，还有交互模式下缩进量的相关处理，略。</p>
<p>缩进量设计自定义函数、递归和类等结构，跟本文主题无关，暂时也不是深入研究。</p>
<p>之后就是很普通的了，扫描字符串然后返回 token，匹配方式比 PHP 难看一些，没有使用正则表达式来表示，而类型跟 PHP 的词法分析差不多，比较大的区别就是 Python 把关键词和变量名&#x2F;函数名&#x2F;类名等合一叫做 NAME，所以定义中的终结符 token 类型就少了很多，具体的定义可以看 token.h，里面有终结符 token 的定义，都是小于 256 的整型数。</p>
<h3 id="语法分析"><a href="#语法分析" class="headerlink" title="语法分析"></a>语法分析</h3><p>语法部分可以看 Grammar 文件，里面有比较好看的语法规则。</p>
<p>parsetok 函数在调用 PyTokenizer_Get 获取 token 之后，会传入 token 和 value 调用 PyParser_AddToken 开始语法分析，跟入这个函数之后就会发现，因为Python 的语法分析器是自己实现的，所以这里的逻辑显得比较难懂。</p>
<p>我们一点点往下看，首先是获取 token 在标签数组里面的数组下标，获取到下标之后有什么用之后再说：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ilabel = classify(ps, type, str);</span><br><span class="line"><span class="keyword">if</span> (ilabel &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> E_SYNTAX;</span><br></pre></td></tr></table></figure>

<p>classify 函数的具体实现如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">classify</span><span class="params">(parser_state *ps, <span class="type">int</span> type, <span class="type">char</span> *str)</span></span><br><span class="line">&#123;</span><br><span class="line">    grammar *g = ps-&gt;p_grammar;</span><br><span class="line">    <span class="keyword">register</span> <span class="type">int</span> n = g-&gt;g_ll.ll_nlabels;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (type == NAME) &#123;</span><br><span class="line">        <span class="keyword">register</span> <span class="type">char</span> *s = str;</span><br><span class="line">        <span class="keyword">register</span> label *l = g-&gt;g_ll.ll_label;</span><br><span class="line">        <span class="keyword">register</span> <span class="type">int</span> i;</span><br><span class="line">        <span class="keyword">for</span> (i = n; i &gt; <span class="number">0</span>; i--, l++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (l-&gt;lb_type != NAME || l-&gt;lb_str == <span class="literal">NULL</span> ||</span><br><span class="line">                l-&gt;lb_str[<span class="number">0</span>] != s[<span class="number">0</span>] ||</span><br><span class="line">                <span class="built_in">strcmp</span>(l-&gt;lb_str, s) != <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PY_PARSER_REQUIRES_FUTURE_KEYWORD</span></span><br><span class="line">            <span class="keyword">if</span> (ps-&gt;p_flags &amp; CO_FUTURE_PRINT_FUNCTION &amp;&amp;</span><br><span class="line">                s[<span class="number">0</span>] == <span class="string">&#x27;p&#x27;</span> &amp;&amp; <span class="built_in">strcmp</span>(s, <span class="string">&quot;print&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>; <span class="comment">/* no longer a keyword */</span></span><br><span class="line">            &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">            D(<span class="built_in">printf</span>(<span class="string">&quot;It&#x27;s a keyword\n&quot;</span>));</span><br><span class="line">            <span class="keyword">return</span> n - i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">register</span> label *l = g-&gt;g_ll.ll_label;</span><br><span class="line">        <span class="keyword">register</span> <span class="type">int</span> i;</span><br><span class="line">        <span class="keyword">for</span> (i = n; i &gt; <span class="number">0</span>; i--, l++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (l-&gt;lb_type == type &amp;&amp; l-&gt;lb_str == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                D(<span class="built_in">printf</span>(<span class="string">&quot;It&#x27;s a token we know\n&quot;</span>));</span><br><span class="line">                <span class="keyword">return</span> n - i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    D(<span class="built_in">printf</span>(<span class="string">&quot;Illegal token\n&quot;</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，如果 token 为 NAME，则尝试将 value 作为一个关键词进行搜索。而搜索失败，或者 value 不为关键词的情况下，则按照 token 进行搜索。</p>
<p>搜索的数组是 g-&gt;g_ll.ll_nlabels，这是个什么东西？我们先看看 g 是个什么东西，在调用 PyParser_ParseFileFlagsEx 函数的时候：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node *n = PyParser_ParseFileFlagsEx(fp, filename, &amp;_PyParser_Grammar, start, ps1, ps2, &amp;err, &amp;iflags);</span><br></pre></td></tr></table></figure>

<p>而 _PyParser_Grammar 则在 graminit.c 里面定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">grammar _PyParser_Grammar = &#123;</span><br><span class="line">    <span class="number">85</span>,</span><br><span class="line">    dfas,</span><br><span class="line">    &#123;<span class="number">169</span>, labels&#125;,</span><br><span class="line">    <span class="number">256</span></span><br><span class="line">&#125;;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span>		 g_ndfas;</span><br><span class="line">    dfa		*g_dfa;		<span class="comment">/* Array of DFAs */</span></span><br><span class="line">    labellist	 g_ll;</span><br><span class="line">    <span class="type">int</span>		 g_start;	<span class="comment">/* Start symbol of the grammar */</span></span><br><span class="line">    <span class="type">int</span>		 g_accel;	<span class="comment">/* Set if accelerators present */</span></span><br><span class="line">&#125; grammar;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span>		 ll_nlabels;</span><br><span class="line">    label	*ll_label;</span><br><span class="line">&#125; labellist;</span><br></pre></td></tr></table></figure>

<p>所以 g-&gt;g_ll.ll_nlabels 其实就是一个长度为 169 的 label 数组 labels，里面存放了所有的 token 和 关键词 NAME，大概是这样子的一个数组：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> label labels[<span class="number">169</span>] = &#123;</span><br><span class="line">    &#123;<span class="number">0</span>, <span class="string">&quot;EMPTY&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="number">256</span>, <span class="number">0</span>&#125;,</span><br><span class="line">    &#123;<span class="number">4</span>, <span class="number">0</span>&#125;,</span><br><span class="line">    &#123;<span class="number">268</span>, <span class="number">0</span>&#125;,</span><br><span class="line">    &#123;<span class="number">292</span>, <span class="number">0</span>&#125;,</span><br><span class="line">    &#123;<span class="number">257</span>, <span class="number">0</span>&#125;,</span><br><span class="line">    &#123;<span class="number">267</span>, <span class="number">0</span>&#125;,</span><br><span class="line">    &#123;<span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">    &#123;<span class="number">258</span>, <span class="number">0</span>&#125;,</span><br><span class="line">    &#123;<span class="number">327</span>, <span class="number">0</span>&#125;,</span><br><span class="line">    &#123;<span class="number">259</span>, <span class="number">0</span>&#125;,</span><br><span class="line">    &#123;<span class="number">50</span>, <span class="number">0</span>&#125;,</span><br><span class="line">    &#123;<span class="number">288</span>, <span class="number">0</span>&#125;,</span><br><span class="line">    &#123;<span class="number">7</span>, <span class="number">0</span>&#125;,</span><br><span class="line">    &#123;<span class="number">330</span>, <span class="number">0</span>&#125;,</span><br><span class="line">    &#123;<span class="number">8</span>, <span class="number">0</span>&#125;,</span><br><span class="line">    &#123;<span class="number">260</span>, <span class="number">0</span>&#125;,</span><br><span class="line">    &#123;<span class="number">261</span>, <span class="number">0</span>&#125;,</span><br><span class="line">    &#123;<span class="number">329</span>, <span class="number">0</span>&#125;,</span><br><span class="line">    &#123;<span class="number">262</span>, <span class="number">0</span>&#125;,</span><br><span class="line">    &#123;<span class="number">1</span>, <span class="string">&quot;def&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="number">1</span>, <span class="number">0</span>&#125;,</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>因为太多就不全放了，每个 label 里面前面是 token，后面则是 value。Python 的语法分析是个栈形&#x2F;树形的过程，其中 0 这个下标表示其中一个 dfa 匹配结束，具体的分析匹配过程后面再说；而 {1, “def”} 代表的就是 def 这个关键词，而 {1, 0} 则代表其他不是关键词的 NAME。</p>
<p>仔细看这个数组会发现，除了 &lt;256 的终结符 token 外，还有一些 &gt;256 的非终结符 token，这些非终结符我们后面再看。</p>
<p>我们回到 PyParser_AddToken，在获取了数组下标之后就进入一个死循环，先看这两句：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">register</span> dfa *d = ps-&gt;p_stack.s_top-&gt;s_dfa;</span><br><span class="line"><span class="keyword">register</span> state *s = &amp;d-&gt;d_state[ps-&gt;p_stack.s_top-&gt;s_state];</span><br></pre></td></tr></table></figure>

<p>ps-&gt;p_stack.s_top 很好理解，就是栈顶，栈的结构如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSTACK 1500</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	<span class="type">int</span>		 s_state;	<span class="comment">/* State in current DFA */</span></span><br><span class="line">	dfa		*s_dfa;		<span class="comment">/* Current DFA */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> _<span class="title">node</span>	*<span class="title">s_parent</span>;</span>	<span class="comment">/* Where to add next node */</span></span><br><span class="line">&#125; stackentry;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	stackentry	*s_top;		<span class="comment">/* Top entry */</span></span><br><span class="line">	stackentry	 s_base[MAXSTACK];<span class="comment">/* Array of stack entries */</span></span><br><span class="line">					<span class="comment">/* NB The stack grows down */</span></span><br><span class="line">&#125; <span class="built_in">stack</span>;</span><br></pre></td></tr></table></figure>

<p>这两句就是从栈顶取出现在匹配状态和匹配中的 dfa，然后根据现在的状态获取 dfa 中的相应状态。dfa 中文名叫有限自动机，简单来说 1 个 dfa 就是语法分析中的一个匹配规则，dfa 的结构定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span>		 d_type;	<span class="comment">/* Non-terminal this represents */</span></span><br><span class="line">    <span class="type">char</span>	*d_name;	<span class="comment">/* For printing */</span></span><br><span class="line">    <span class="type">int</span>		 d_initial;	<span class="comment">/* Initial state */</span></span><br><span class="line">    <span class="type">int</span>		 d_nstates;</span><br><span class="line">    state	*d_state;	<span class="comment">/* Array of states */</span></span><br><span class="line">    <span class="built_in">bitset</span>	 d_first;</span><br><span class="line">&#125; dfa;</span><br></pre></td></tr></table></figure>

<p>这些 dfa 也存放在 graminit.c 的一个数组里面：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> dfa dfas[<span class="number">85</span>] = &#123;</span><br><span class="line">    &#123;<span class="number">256</span>, <span class="string">&quot;single_input&quot;</span>, <span class="number">0</span>, <span class="number">3</span>, states_0,</span><br><span class="line">     <span class="string">&quot;\004\050\060\000\000\000\000\124\360\024\114\220\023\040\010\000\200\041\044\015\002\001&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="number">257</span>, <span class="string">&quot;file_input&quot;</span>, <span class="number">0</span>, <span class="number">2</span>, states_1,</span><br><span class="line">     <span class="string">&quot;\204\050\060\000\000\000\000\124\360\024\114\220\023\040\010\000\200\041\044\015\002\001&quot;</span>&#125;,</span><br><span class="line">    ...</span><br><span class="line">    &#123;<span class="number">267</span>, <span class="string">&quot;stmt&quot;</span>, <span class="number">0</span>, <span class="number">2</span>, states_11,</span><br><span class="line">     <span class="string">&quot;\000\050\060\000\000\000\000\124\360\024\114\220\023\040\010\000\200\041\044\015\002\001&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="number">268</span>, <span class="string">&quot;simple_stmt&quot;</span>, <span class="number">0</span>, <span class="number">4</span>, states_12,</span><br><span class="line">     <span class="string">&quot;\000\040\040\000\000\000\000\124\360\024\114\000\000\040\010\000\200\041\044\015\000\001&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="number">269</span>, <span class="string">&quot;small_stmt&quot;</span>, <span class="number">0</span>, <span class="number">2</span>, states_13,</span><br><span class="line">     <span class="string">&quot;\000\040\040\000\000\000\000\124\360\024\114\000\000\040\010\000\200\041\044\015\000\001&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="number">270</span>, <span class="string">&quot;expr_stmt&quot;</span>, <span class="number">0</span>, <span class="number">6</span>, states_14,</span><br><span class="line">     <span class="string">&quot;\000\040\040\000\000\000\000\000\000\000\000\000\000\040\010\000\200\041\044\015\000\000&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="number">271</span>, <span class="string">&quot;augassign&quot;</span>, <span class="number">0</span>, <span class="number">2</span>, states_15,</span><br><span class="line">     <span class="string">&quot;\000\000\000\000\000\300\377\003\000\000\000\000\000\000\000\000\000\000\000\000\000\000&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="number">272</span>, <span class="string">&quot;print_stmt&quot;</span>, <span class="number">0</span>, <span class="number">9</span>, states_16,</span><br><span class="line">     <span class="string">&quot;\000\000\000\000\000\000\000\004\000\000\000\000\000\000\000\000\000\000\000\000\000\000&quot;</span>&#125;,</span><br><span class="line">    ...</span><br><span class="line">    &#123;<span class="number">304</span>, <span class="string">&quot;test&quot;</span>, <span class="number">0</span>, <span class="number">6</span>, states_48,</span><br><span class="line">     <span class="string">&quot;\000\040\040\000\000\000\000\000\000\000\000\000\000\040\010\000\200\041\044\015\000\000&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="number">305</span>, <span class="string">&quot;or_test&quot;</span>, <span class="number">0</span>, <span class="number">2</span>, states_49,</span><br><span class="line">     <span class="string">&quot;\000\040\040\000\000\000\000\000\000\000\000\000\000\000\010\000\200\041\044\015\000\000&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="number">306</span>, <span class="string">&quot;and_test&quot;</span>, <span class="number">0</span>, <span class="number">2</span>, states_50,</span><br><span class="line">     <span class="string">&quot;\000\040\040\000\000\000\000\000\000\000\000\000\000\000\010\000\200\041\044\015\000\000&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="number">307</span>, <span class="string">&quot;not_test&quot;</span>, <span class="number">0</span>, <span class="number">3</span>, states_51,</span><br><span class="line">     <span class="string">&quot;\000\040\040\000\000\000\000\000\000\000\000\000\000\000\010\000\200\041\044\015\000\000&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="number">308</span>, <span class="string">&quot;comparison&quot;</span>, <span class="number">0</span>, <span class="number">2</span>, states_52,</span><br><span class="line">     <span class="string">&quot;\000\040\040\000\000\000\000\000\000\000\000\000\000\000\000\000\200\041\044\015\000\000&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="number">309</span>, <span class="string">&quot;comp_op&quot;</span>, <span class="number">0</span>, <span class="number">4</span>, states_53,</span><br><span class="line">     <span class="string">&quot;\000\000\000\000\000\000\000\000\000\000\040\000\000\000\310\077\000\000\000\000\000\000&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="number">310</span>, <span class="string">&quot;expr&quot;</span>, <span class="number">0</span>, <span class="number">2</span>, states_54,</span><br><span class="line">     <span class="string">&quot;\000\040\040\000\000\000\000\000\000\000\000\000\000\000\000\000\200\041\044\015\000\000&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="number">311</span>, <span class="string">&quot;xor_expr&quot;</span>, <span class="number">0</span>, <span class="number">2</span>, states_55,</span><br><span class="line">     <span class="string">&quot;\000\040\040\000\000\000\000\000\000\000\000\000\000\000\000\000\200\041\044\015\000\000&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="number">312</span>, <span class="string">&quot;and_expr&quot;</span>, <span class="number">0</span>, <span class="number">2</span>, states_56,</span><br><span class="line">     <span class="string">&quot;\000\040\040\000\000\000\000\000\000\000\000\000\000\000\000\000\200\041\044\015\000\000&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="number">313</span>, <span class="string">&quot;shift_expr&quot;</span>, <span class="number">0</span>, <span class="number">2</span>, states_57,</span><br><span class="line">     <span class="string">&quot;\000\040\040\000\000\000\000\000\000\000\000\000\000\000\000\000\200\041\044\015\000\000&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="number">314</span>, <span class="string">&quot;arith_expr&quot;</span>, <span class="number">0</span>, <span class="number">2</span>, states_58,</span><br><span class="line">     <span class="string">&quot;\000\040\040\000\000\000\000\000\000\000\000\000\000\000\000\000\200\041\044\015\000\000&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="number">315</span>, <span class="string">&quot;term&quot;</span>, <span class="number">0</span>, <span class="number">2</span>, states_59,</span><br><span class="line">     <span class="string">&quot;\000\040\040\000\000\000\000\000\000\000\000\000\000\000\000\000\200\041\044\015\000\000&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="number">316</span>, <span class="string">&quot;factor&quot;</span>, <span class="number">0</span>, <span class="number">3</span>, states_60,</span><br><span class="line">     <span class="string">&quot;\000\040\040\000\000\000\000\000\000\000\000\000\000\000\000\000\200\041\044\015\000\000&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="number">317</span>, <span class="string">&quot;power&quot;</span>, <span class="number">0</span>, <span class="number">4</span>, states_61,</span><br><span class="line">     <span class="string">&quot;\000\040\040\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\044\015\000\000&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="number">318</span>, <span class="string">&quot;atom&quot;</span>, <span class="number">0</span>, <span class="number">11</span>, states_62,</span><br><span class="line">     <span class="string">&quot;\000\040\040\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\044\015\000\000&quot;</span>&#125;,</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>看过 Gammar 文件里面语法之后就会发现，这里的 dfa 其实就是非终结符 token，第一个数字就是他们的 token，第二个则是他们易读的书面形式。至于后面四个成员则涉及匹配中的状态转换，分别代表该 dfa 的初始状态、状态数量、状态定义&#x2F;转换以及可接受的首个 token(这里接受与否使用八进制表示的，比如 print_stmt 的 \000\000\000\000\000\000\000\004，表示的就是数组下标 58，即可接受的首个 token 就是关键词 print)，详细的转换过程后面再说。</p>
<p>继续往下看：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (s-&gt;s_lower &lt;= ilabel &amp;&amp; ilabel &lt; s-&gt;s_upper) &#123;</span><br><span class="line">    <span class="keyword">register</span> <span class="type">int</span> x = s-&gt;s_accel[ilabel - s-&gt;s_lower];</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>s 就是前面获取的状态，结构如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">short</span>	a_lbl;		<span class="comment">/* Label of this arc */</span></span><br><span class="line">    <span class="type">short</span>	a_arrow;	<span class="comment">/* State where this arc goes to */</span></span><br><span class="line">&#125; arc;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* A state in a DFA */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span>		 s_narcs;</span><br><span class="line">    arc		*s_arc;		<span class="comment">/* Array of arcs */</span></span><br><span class="line">	</span><br><span class="line">    <span class="comment">/* Optional accelerators */</span></span><br><span class="line">    <span class="type">int</span>		 s_lower;	<span class="comment">/* Lowest label index */</span></span><br><span class="line">    <span class="type">int</span>		 s_upper;	<span class="comment">/* Highest label index */</span></span><br><span class="line">    <span class="type">int</span>		*s_accel;	<span class="comment">/* Accelerator */</span></span><br><span class="line">    <span class="type">int</span>		 s_accept;	<span class="comment">/* Nonzero for accepting state */</span></span><br><span class="line">&#125; state;</span><br></pre></td></tr></table></figure>

<p>其中 s_lower 代表能接受的最小数组下标，s_upper 则是最大数组下标，s_accel 下标代表可接受的首个 token、值代表接受后转换成的状态，s_accept 代表能否结束这个 dfa 的匹配。这些数据同样初始化在 graminit.c 中，比如 file_input 这个 dfa 的状态集及其转换规则就是：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> arc arcs_1_0[<span class="number">3</span>] = &#123;</span><br><span class="line">    &#123;<span class="number">2</span>, <span class="number">0</span>&#125;,</span><br><span class="line">    &#123;<span class="number">6</span>, <span class="number">0</span>&#125;,</span><br><span class="line">    &#123;<span class="number">7</span>, <span class="number">1</span>&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> arc arcs_1_1[<span class="number">1</span>] = &#123;</span><br><span class="line">    &#123;<span class="number">0</span>, <span class="number">1</span>&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> state states_1[<span class="number">2</span>] = &#123;</span><br><span class="line">    &#123;<span class="number">3</span>, arcs_1_0&#125;,</span><br><span class="line">    &#123;<span class="number">1</span>, arcs_1_1&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>每个状态中的两个数据分别代表转换规则数、转换规则集，而每条转换规则中的两个数据代表可以匹配的 labels 中的数组下标、匹配后要转换成的状态。而每个 dfa 的初试状态都是 0，也就是说接受 token 后会按照 arcs_1_0 中的规则进行状态转换，如果 token 下标为 2、6 则会转换为 0，7则会转换为 1。</p>
<p>这里就会发现，初始化定义里面是没有 s_lower 以及后面的数据的，而 dfa 和栈等分析所需的数据都来自 ps 这个 parser_state 结构体：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	<span class="built_in">stack</span>	 	p_stack;	<span class="comment">/* Stack of parser states */</span></span><br><span class="line">	grammar		*p_grammar;	<span class="comment">/* Grammar to use */</span></span><br><span class="line">	node		*p_tree;	<span class="comment">/* Top of parse tree */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PY_PARSER_REQUIRES_FUTURE_KEYWORD</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>	p_flags;	<span class="comment">/* see co_flags in Include/code.h */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125; parser_state;</span><br></pre></td></tr></table></figure>

<p>可以看到里面有栈、语法规则、AST 树等成员，我们回去看看它的初始化，回到 parsetok 函数中，这里有个 PyParser_New 函数调用：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">parser_state *</span><br><span class="line"><span class="title function_">PyParser_New</span><span class="params">(grammar *g, <span class="type">int</span> start)</span></span><br><span class="line">&#123;</span><br><span class="line">    parser_state *ps;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!g-&gt;g_accel)</span><br><span class="line">        PyGrammar_AddAccelerators(g);</span><br><span class="line">    ps = (parser_state *)PyMem_MALLOC(<span class="keyword">sizeof</span>(parser_state));</span><br><span class="line">    <span class="keyword">if</span> (ps == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    ps-&gt;p_grammar = g;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PY_PARSER_REQUIRES_FUTURE_KEYWORD</span></span><br><span class="line">    ps-&gt;p_flags = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    ps-&gt;p_tree = PyNode_New(start);</span><br><span class="line">    <span class="keyword">if</span> (ps-&gt;p_tree == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        PyMem_FREE(ps);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    s_reset(&amp;ps-&gt;p_stack);</span><br><span class="line">    (<span class="type">void</span>) s_push(&amp;ps-&gt;p_stack, PyGrammar_FindDFA(g, start), ps-&gt;p_tree);</span><br><span class="line">    <span class="keyword">return</span> ps;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">s_push</span><span class="params">(<span class="keyword">register</span> <span class="built_in">stack</span> *s, dfa *d, node *parent)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">register</span> stackentry *top;</span><br><span class="line">    <span class="keyword">if</span> (s-&gt;s_top == s-&gt;s_base) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;s_push: parser stack overflow\n&quot;</span>);<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> E_NOMEM;</span><br><span class="line">    &#125;</span><br><span class="line">    top = --s-&gt;s_top;</span><br><span class="line">    top-&gt;s_dfa = d;</span><br><span class="line">    top-&gt;s_parent = parent;</span><br><span class="line">    top-&gt;s_state = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在命令行运行 python 文件的情况下，这里的 start 为 257，即代表 file_input 的 token，可以看到最后会将 file_input 的 dfa 压入栈中作为匹配的开始，并让 ps-&gt;p_tree 指向 AST 树的根。我们关注 PyGrammar_AddAccelerators 函数，状态转换中重要的 s_accel 等成员都是在这里生成的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">PyGrammar_AddAccelerators</span><span class="params">(grammar *g)</span></span><br><span class="line">&#123;</span><br><span class="line">    dfa *d;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    d = g-&gt;g_dfa;</span><br><span class="line">    <span class="keyword">for</span> (i = g-&gt;g_ndfas; --i &gt;= <span class="number">0</span>; d++)</span><br><span class="line">        fixdfa(g, d);</span><br><span class="line">    g-&gt;g_accel = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>遍历所有的 dfa，然后对每个 dfa 调用 fixdfa，继续看：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">fixdfa</span><span class="params">(grammar *g, dfa *d)</span></span><br><span class="line">&#123;</span><br><span class="line">    state *s;</span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line">    s = d-&gt;d_state;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; d-&gt;d_nstates; j++, s++)</span><br><span class="line">        fixstate(g, s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再遍历 dfa 中的状态集，对每个状态调用 fixstate：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">fixstate</span><span class="params">(grammar *g, state *s)</span></span><br><span class="line">&#123;</span><br><span class="line">    arc *a;</span><br><span class="line">    <span class="type">int</span> k;</span><br><span class="line">    <span class="type">int</span> *accel;</span><br><span class="line">    <span class="type">int</span> nl = g-&gt;g_ll.ll_nlabels;</span><br><span class="line">    s-&gt;s_accept = <span class="number">0</span>;</span><br><span class="line">    accel = (<span class="type">int</span> *) PyObject_MALLOC(nl * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="keyword">if</span> (accel == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;no mem to build parser accelerators\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; nl; k++)</span><br><span class="line">        accel[k] = <span class="number">-1</span>;</span><br><span class="line">    a = s-&gt;s_arc;</span><br><span class="line">    <span class="keyword">for</span> (k = s-&gt;s_narcs; --k &gt;= <span class="number">0</span>; a++) &#123;</span><br><span class="line">        <span class="type">int</span> lbl = a-&gt;a_lbl;</span><br><span class="line">        label *l = &amp;g-&gt;g_ll.ll_label[lbl];</span><br><span class="line">        <span class="type">int</span> type = l-&gt;lb_type;</span><br><span class="line">        <span class="keyword">if</span> (a-&gt;a_arrow &gt;= (<span class="number">1</span> &lt;&lt; <span class="number">7</span>)) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;XXX too many states!\n&quot;</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ISNONTERMINAL(type)) &#123;</span><br><span class="line">            dfa *d1 = PyGrammar_FindDFA(g, type);</span><br><span class="line">            <span class="type">int</span> ibit;</span><br><span class="line">            <span class="keyword">if</span> (type - NT_OFFSET &gt;= (<span class="number">1</span> &lt;&lt; <span class="number">7</span>)) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;XXX too high nonterminal number!\n&quot;</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (ibit = <span class="number">0</span>; ibit &lt; g-&gt;g_ll.ll_nlabels; ibit++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (testbit(d1-&gt;d_first, ibit)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (accel[ibit] != <span class="number">-1</span>)</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;XXX ambiguity!\n&quot;</span>);</span><br><span class="line">                    accel[ibit] = a-&gt;a_arrow | (<span class="number">1</span> &lt;&lt; <span class="number">7</span>) |</span><br><span class="line">                        ((type - NT_OFFSET) &lt;&lt; <span class="number">8</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (lbl == EMPTY)</span><br><span class="line">            s-&gt;s_accept = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (lbl &gt;= <span class="number">0</span> &amp;&amp; lbl &lt; nl)</span><br><span class="line">            accel[lbl] = a-&gt;a_arrow;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (nl &gt; <span class="number">0</span> &amp;&amp; accel[nl<span class="number">-1</span>] == <span class="number">-1</span>)</span><br><span class="line">        nl--;</span><br><span class="line">    <span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; nl &amp;&amp; accel[k] == <span class="number">-1</span>;)</span><br><span class="line">        k++;</span><br><span class="line">    <span class="keyword">if</span> (k &lt; nl) &#123;</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        s-&gt;s_accel = (<span class="type">int</span> *) PyObject_MALLOC((nl-k) * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">        <span class="keyword">if</span> (s-&gt;s_accel == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;no mem to add parser accelerators\n&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        s-&gt;s_lower = k;</span><br><span class="line">        s-&gt;s_upper = nl;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; k &lt; nl; i++, k++)</span><br><span class="line">            s-&gt;s_accel[i] = accel[k];</span><br><span class="line">    &#125;</span><br><span class="line">    PyObject_FREE(accel);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结一下过程，首先生成一个跟 labels 数组相同长度的 int 数组，全部赋值为 -1，代表不接受这个数组下标代表的 token。</p>
<p>然后遍历该状态的转换规则计算可以接受的首个 token，根据该规则可以匹配的数组下标从 labels 中取出对应的 token，然后判断 token 的类型，如果是 0，代表这次转换可以结束这个 dfa 的匹配，然后将 s_accept 赋值为 1，代表这个状态可以转换到匹配结束的接受状态。如果是其他终结符，则将转换后的状态放入 accel 中。而如果是非终结符，则要取出该非终结符对应的 dfa，根据其八进制 biset 来确定能接受的首个 token：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(((d1-&gt;d_first)[((ibit) / (<span class="number">8</span>*<span class="keyword">sizeof</span>(<span class="type">char</span>)))] &amp; (<span class="number">1</span> &lt;&lt; ((ibit) % (<span class="number">8</span>*<span class="keyword">sizeof</span>(<span class="type">char</span>))))) != <span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<p>再将转换后的状态、代表非终结符的 1、代表非终结符 token 的数字 - 256 之后组合起来放入 accel：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">accel[ibit] = a-&gt;a_arrow | (<span class="number">1</span> &lt;&lt; <span class="number">7</span>) | ((type - NT_OFFSET) &lt;&lt; <span class="number">8</span>);</span><br></pre></td></tr></table></figure>

<p>后面就很简单了，从前遍历找到能接受的最小下标作为 s_lower，从后找到能接受的最大下标作为 s_upper，再将接受和转换的规则放入 s_accel 中。</p>
<p>这时候回过头来继续看 PyParser_AddToken 函数里面的状态转换就很好懂了，用测试脚本举例，语法分析过程如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">Token NAME/&#x27;print&#x27; ... It&#x27;s a keyword</span><br><span class="line"> DFA &#x27;file_input&#x27;, state 0: Push ...</span><br><span class="line"> DFA &#x27;stmt&#x27;, state 0: Push ...</span><br><span class="line"> DFA &#x27;simple_stmt&#x27;, state 0: Push ...</span><br><span class="line"> DFA &#x27;small_stmt&#x27;, state 0: Push ...</span><br><span class="line"> DFA &#x27;print_stmt&#x27;, state 0: Shift.</span><br><span class="line">Token NUMBER/&#x27;1&#x27; ... It&#x27;s a token we know</span><br><span class="line"> DFA &#x27;print_stmt&#x27;, state 1: Push ...</span><br><span class="line"> DFA &#x27;test&#x27;, state 0: Push ...</span><br><span class="line"> DFA &#x27;or_test&#x27;, state 0: Push ...</span><br><span class="line"> DFA &#x27;and_test&#x27;, state 0: Push ...</span><br><span class="line"> DFA &#x27;not_test&#x27;, state 0: Push ...</span><br><span class="line"> DFA &#x27;comparison&#x27;, state 0: Push ...</span><br><span class="line"> DFA &#x27;expr&#x27;, state 0: Push ...</span><br><span class="line"> DFA &#x27;xor_expr&#x27;, state 0: Push ...</span><br><span class="line"> DFA &#x27;and_expr&#x27;, state 0: Push ...</span><br><span class="line"> DFA &#x27;shift_expr&#x27;, state 0: Push ...</span><br><span class="line"> DFA &#x27;arith_expr&#x27;, state 0: Push ...</span><br><span class="line"> DFA &#x27;term&#x27;, state 0: Push ...</span><br><span class="line"> DFA &#x27;factor&#x27;, state 0: Push ...</span><br><span class="line"> DFA &#x27;power&#x27;, state 0: Push ...</span><br><span class="line"> DFA &#x27;atom&#x27;, state 0: Shift.</span><br><span class="line">  DFA &#x27;atom&#x27;, state 5: Direct pop.</span><br><span class="line">Token NEWLINE/&#x27;&#x27; ... It&#x27;s a token we know</span><br><span class="line"> DFA &#x27;power&#x27;, state 1: Pop ...</span><br><span class="line"> DFA &#x27;factor&#x27;, state 2: Pop ...</span><br><span class="line"> DFA &#x27;term&#x27;, state 1: Pop ...</span><br><span class="line"> DFA &#x27;arith_expr&#x27;, state 1: Pop ...</span><br><span class="line"> DFA &#x27;shift_expr&#x27;, state 1: Pop ...</span><br><span class="line"> DFA &#x27;and_expr&#x27;, state 1: Pop ...</span><br><span class="line"> DFA &#x27;xor_expr&#x27;, state 1: Pop ...</span><br><span class="line"> DFA &#x27;expr&#x27;, state 1: Pop ...</span><br><span class="line"> DFA &#x27;comparison&#x27;, state 1: Pop ...</span><br><span class="line"> DFA &#x27;not_test&#x27;, state 2: Pop ...</span><br><span class="line"> DFA &#x27;and_test&#x27;, state 1: Pop ...</span><br><span class="line"> DFA &#x27;or_test&#x27;, state 1: Pop ...</span><br><span class="line"> DFA &#x27;test&#x27;, state 1: Pop ...</span><br><span class="line"> DFA &#x27;print_stmt&#x27;, state 2: Pop ...</span><br><span class="line"> DFA &#x27;small_stmt&#x27;, state 1: Pop ...</span><br><span class="line"> DFA &#x27;simple_stmt&#x27;, state 1: Shift.</span><br><span class="line">  DFA &#x27;simple_stmt&#x27;, state 3: Direct pop.</span><br><span class="line">  DFA &#x27;stmt&#x27;, state 1: Direct pop.</span><br><span class="line">Token NEWLINE/&#x27;&#x27; ... It&#x27;s a token we know</span><br><span class="line"> DFA &#x27;file_input&#x27;, state 0: Shift.</span><br><span class="line">Token ENDMARKER/&#x27;&#x27; ... It&#x27;s a token we know</span><br><span class="line"> DFA &#x27;file_input&#x27;, state 0: Shift.</span><br><span class="line">  DFA &#x27;file_input&#x27;, state 1: Direct pop.</span><br><span class="line">  ACCEPT.</span><br></pre></td></tr></table></figure>

<p>后面的两个 NEWLINE 和 ENDMARKER 是 python 添加上去的，源码里没有这几个标记。</p>
<p>首先，词法分析返回一个 NAME，语法分析首先调用 classify 进行确认，发现这是个关键词，然后从栈上取出 file_input 的 dfa，查询 file_input 是否接受这个关键词：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">register</span> <span class="type">int</span> x = s-&gt;s_accel[ilabel - s-&gt;s_lower];</span><br><span class="line"><span class="keyword">if</span> (x != <span class="number">-1</span>) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后判断接受这个关键词的下一个 dfa 是否属于非终结符：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (x &amp; (<span class="number">1</span>&lt;&lt;<span class="number">7</span>)) &#123;</span><br><span class="line">    <span class="comment">/* Push non-terminal */</span></span><br><span class="line">    <span class="type">int</span> nt = (x &gt;&gt; <span class="number">8</span>) + NT_OFFSET;</span><br><span class="line">    <span class="type">int</span> arrow = x &amp; ((<span class="number">1</span>&lt;&lt;<span class="number">7</span>)<span class="number">-1</span>);</span><br><span class="line">    dfa *d1 = PyGrammar_FindDFA(ps-&gt;p_grammar, nt);</span><br><span class="line">    <span class="keyword">if</span> ((err = push(&amp;ps-&gt;p_stack, nt, d1,</span><br><span class="line">        arrow, lineno, col_offset)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        D(<span class="built_in">printf</span>(<span class="string">&quot; MemError: push\n&quot;</span>));</span><br><span class="line">        <span class="keyword">return</span> err;</span><br><span class="line">    &#125;</span><br><span class="line">    D(<span class="built_in">printf</span>(<span class="string">&quot; Push ...\n&quot;</span>));</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果属于非终结符则取出该非终结符的 token 和接受并转换后的状态，这里是 stmt 和 1，并将该非终结符的 dfa 作为下一次匹配的规则压入栈中。实际上 push 函数里面除了入栈，还对 AST 树进行了操作：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">push</span><span class="params">(<span class="keyword">register</span> <span class="built_in">stack</span> *s, <span class="type">int</span> type, dfa *d, <span class="type">int</span> newstate, <span class="type">int</span> lineno, <span class="type">int</span> col_offset)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> err;</span><br><span class="line">    <span class="keyword">register</span> node *n;</span><br><span class="line">    n = s-&gt;s_top-&gt;s_parent;</span><br><span class="line">    assert(!s_empty(s));</span><br><span class="line">    err = PyNode_AddChild(n, type, (<span class="type">char</span> *)<span class="literal">NULL</span>, lineno, col_offset);</span><br><span class="line">    <span class="keyword">if</span> (err)</span><br><span class="line">        <span class="keyword">return</span> err;</span><br><span class="line">    s-&gt;s_top-&gt;s_state = newstate;</span><br><span class="line">    <span class="keyword">return</span> s_push(s, d, CHILD(n, NCH(n)<span class="number">-1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时 s-&gt;s_top-&gt;s_parent 就是 AST 树的根节点，调用 PyNode_AddChild 会将非终结符 stmt 挂到根节点的子节点上面，s_push 则会将栈顶元素的 s_parent 修改为这个 stmt 的节点，也就是说下一次 push 形成的子节点就会挂在 stmt 节点的子节点上面，这样就构成了一棵 AST 树。</p>
<p>就这样一遍遍重复将下一个 dfa 压入栈中，直到遇到非终结符 print_stmt，此时接受关键词的是值为 print 的终结符 NAME，所以会不会进入前面的判断，而是开始尝试出栈：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Shift the token */</span></span><br><span class="line"><span class="keyword">if</span> ((err = shift(&amp;ps-&gt;p_stack, type, str, x, lineno, col_offset)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    D(<span class="built_in">printf</span>(<span class="string">&quot; MemError: shift.\n&quot;</span>));</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line">D(<span class="built_in">printf</span>(<span class="string">&quot; Shift.\n&quot;</span>));</span><br><span class="line"><span class="comment">/* Pop while we are in an accept-only state */</span></span><br><span class="line"><span class="keyword">while</span> (s = &amp;d-&gt;d_state[ps-&gt;p_stack.s_top-&gt;s_state], s-&gt;s_accept &amp;&amp; s-&gt;s_narcs == <span class="number">1</span>) &#123;</span><br><span class="line">    D(<span class="built_in">printf</span>(<span class="string">&quot;  DFA &#x27;%s&#x27;, state %d: &quot;</span> <span class="string">&quot;Direct pop.\n&quot;</span>, d-&gt;d_name, ps-&gt;p_stack.s_top-&gt;s_state));</span><br><span class="line">    <span class="meta">#<span class="keyword">ifdef</span> PY_PARSER_REQUIRES_FUTURE_KEYWORD</span></span><br><span class="line">    <span class="keyword">if</span> (d-&gt;d_name[<span class="number">0</span>] == <span class="string">&#x27;i&#x27;</span> &amp;&amp; <span class="built_in">strcmp</span>(d-&gt;d_name, <span class="string">&quot;import_stmt&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">        future_hack(ps);</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    s_pop(&amp;ps-&gt;p_stack);</span><br><span class="line">    <span class="keyword">if</span> (s_empty(&amp;ps-&gt;p_stack)) &#123;</span><br><span class="line">        D(<span class="built_in">printf</span>(<span class="string">&quot;  ACCEPT.\n&quot;</span>));</span><br><span class="line">        <span class="keyword">return</span> E_DONE;</span><br><span class="line">    &#125;</span><br><span class="line">    d = ps-&gt;p_stack.s_top-&gt;s_dfa;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> E_OK;</span><br></pre></td></tr></table></figure>

<p>shift 的操作跟 push 相同，只是少了入栈。阅读 Grammar 中的语法，可以发现对于非终结符而言，可能会有跟现在的 atom 一样的情况，即接受完一个 token 之后不能再继续接受第二个 token 了，这个时候就需要直接将其出栈，否则会影响到下一个 token 的分析，而这种直接出栈的情况在代码中的实现就是将状态转换成一个只接受 0 这个下标的状态，即：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s-&gt;s_accept &amp;&amp; s-&gt;s_narcs == <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>到这里，关键词 print 的分析就完成了，我们根据转换规则看下 print_stmt 的转换过程：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// print_stmt 的状态 0 转换集，下标 58 代表关键词 print</span></span><br><span class="line"><span class="type">static</span> arc arcs_16_0[<span class="number">1</span>] = &#123;</span><br><span class="line">    &#123;<span class="number">58</span>, <span class="number">1</span>&#125;, <span class="comment">// 终结符 print</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> arc arcs_16_1[<span class="number">3</span>] = &#123;</span><br><span class="line">    &#123;<span class="number">28</span>, <span class="number">2</span>&#125;, <span class="comment">// 非终结符 test</span></span><br><span class="line">    &#123;<span class="number">59</span>, <span class="number">3</span>&#125;, <span class="comment">// 终结符 &gt;&gt;</span></span><br><span class="line">    &#123;<span class="number">0</span>, <span class="number">1</span>&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> arc arcs_16_2[<span class="number">2</span>] = &#123;</span><br><span class="line">    &#123;<span class="number">29</span>, <span class="number">4</span>&#125;, <span class="comment">// 终结符 ,</span></span><br><span class="line">    &#123;<span class="number">0</span>, <span class="number">2</span>&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> arc arcs_16_3[<span class="number">1</span>] = &#123;</span><br><span class="line">    &#123;<span class="number">28</span>, <span class="number">5</span>&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> arc arcs_16_4[<span class="number">2</span>] = &#123;</span><br><span class="line">    &#123;<span class="number">28</span>, <span class="number">2</span>&#125;,</span><br><span class="line">    &#123;<span class="number">0</span>, <span class="number">4</span>&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> arc arcs_16_5[<span class="number">2</span>] = &#123;</span><br><span class="line">    &#123;<span class="number">29</span>, <span class="number">6</span>&#125;,</span><br><span class="line">    &#123;<span class="number">0</span>, <span class="number">5</span>&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> arc arcs_16_6[<span class="number">1</span>] = &#123;</span><br><span class="line">    &#123;<span class="number">28</span>, <span class="number">7</span>&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> arc arcs_16_7[<span class="number">2</span>] = &#123;</span><br><span class="line">    &#123;<span class="number">29</span>, <span class="number">8</span>&#125;,</span><br><span class="line">    &#123;<span class="number">0</span>, <span class="number">7</span>&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> arc arcs_16_8[<span class="number">2</span>] = &#123;</span><br><span class="line">    &#123;<span class="number">28</span>, <span class="number">7</span>&#125;,</span><br><span class="line">    &#123;<span class="number">0</span>, <span class="number">8</span>&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>初始状态 0，接受 print 转换为 1，此时可以接受非终结符 test 或者终结符 &gt;&gt;。接受 test 之后会转换成 2，可以接受终结符 , 并转换为 4，然后就是一个不断的循环 , test , test , test …。注意看会发现状态 2 的转换规则里面还有一条 {0, 2}，这其实是这个状态可以作为结束状态的意思，因为这个状态的 s_accept 会是 1，后面的判断里面会依此判断该 dfa 是否匹配完全了，而放在现在这个情景中的意思就是 print 后面可以只有一个 test，而不需要后面更多的 , 和 test。这部分也就是 Grammar 里面写的规则：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[ test (<span class="string">&#x27;,&#x27;</span> test)* [<span class="string">&#x27;,&#x27;</span>] ]</span><br></pre></td></tr></table></figure>

<p>接下来会读入一个 token NUMBER 进行分析，此时的栈顶 dfa 为 print_stmt，状态为 1，所以下一个接受的 dfa 为 test，同样一路入栈，最后到非终结符 atom，它接受终结符 NUMBER 并转换为状态 5：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> arc arcs_62_0[<span class="number">7</span>] = &#123;</span><br><span class="line">    &#123;<span class="number">13</span>, <span class="number">1</span>&#125;,</span><br><span class="line">    &#123;<span class="number">146</span>, <span class="number">2</span>&#125;,</span><br><span class="line">    &#123;<span class="number">149</span>, <span class="number">3</span>&#125;,</span><br><span class="line">    &#123;<span class="number">152</span>, <span class="number">4</span>&#125;,</span><br><span class="line">    &#123;<span class="number">21</span>, <span class="number">5</span>&#125;,</span><br><span class="line">    &#123;<span class="number">154</span>, <span class="number">5</span>&#125;,</span><br><span class="line">    &#123;<span class="number">155</span>, <span class="number">6</span>&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> arc arcs_62_5[<span class="number">1</span>] = &#123;</span><br><span class="line">    &#123;<span class="number">0</span>, <span class="number">5</span>&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>而因为状态 5 的转换规则只有一个 0，所以会直接出栈，栈顶 dfa 变为 power，此时 power 的状态为 1。</p>
<p>接下来读入的 token 是 NEWLINE，而 power 状态 1 不接受这个 token，所以会直接来到最后的两部分处理：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (s-&gt;s_accept) &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PY_PARSER_REQUIRES_FUTURE_KEYWORD</span></span><br><span class="line">    <span class="keyword">if</span> (d-&gt;d_name[<span class="number">0</span>] == <span class="string">&#x27;i&#x27;</span> &amp;&amp;</span><br><span class="line">        <span class="built_in">strcmp</span>(d-&gt;d_name, <span class="string">&quot;import_stmt&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">        future_hack(ps);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="comment">/* Pop this dfa and try again */</span></span><br><span class="line">    s_pop(&amp;ps-&gt;p_stack);</span><br><span class="line">    D(<span class="built_in">printf</span>(<span class="string">&quot; Pop ...\n&quot;</span>));</span><br><span class="line">    <span class="keyword">if</span> (s_empty(&amp;ps-&gt;p_stack)) &#123;</span><br><span class="line">        D(<span class="built_in">printf</span>(<span class="string">&quot; Error: bottom of stack.\n&quot;</span>));</span><br><span class="line">        <span class="keyword">return</span> E_SYNTAX;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Stuck, report syntax error */</span></span><br><span class="line">D(<span class="built_in">printf</span>(<span class="string">&quot; Error.\n&quot;</span>));</span><br><span class="line"><span class="keyword">if</span> (expected_ret) &#123;</span><br><span class="line">    <span class="keyword">if</span> (s-&gt;s_lower == s-&gt;s_upper - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">/* Only one possible expected token */</span></span><br><span class="line">        *expected_ret = ps-&gt;p_grammar-&gt;</span><br><span class="line">            g_ll.ll_label[s-&gt;s_lower].lb_type;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        *expected_ret = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> E_SYNTAX;</span><br></pre></td></tr></table></figure>

<p>如果该状态的 s_accept 为 1，代表这个状态已经匹配完全，可以结束该 dfa 的匹配了，则可以将该 dfa 出栈并返回继续上一个 dfa 的匹配。如果 s_accept  为 0 而 dfa 又不接受这个 token，则代表语法错误了。</p>
<p>而 power 状态 1 的规则如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> arc arcs_61_1[<span class="number">3</span>] = &#123;</span><br><span class="line">    &#123;<span class="number">144</span>, <span class="number">1</span>&#125;,</span><br><span class="line">    &#123;<span class="number">31</span>, <span class="number">2</span>&#125;,</span><br><span class="line">    &#123;<span class="number">0</span>, <span class="number">1</span>&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>所以可以出栈，继续 factor 的匹配，这样一路出栈入栈，最后一个 Direct pop 清空栈里面的 dfa 之后，语法分析就完成了。</p>
<h3 id="解析-AST-树"><a href="#解析-AST-树" class="headerlink" title="解析 AST 树"></a>解析 AST 树</h3><p>AST 节点结构体：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="type">short</span>		n_type; <span class="comment">// token</span></span><br><span class="line">    <span class="type">char</span>		*n_str; <span class="comment">// 书面表达</span></span><br><span class="line">    <span class="type">int</span>			n_lineno; </span><br><span class="line">    <span class="type">int</span>			n_col_offset;</span><br><span class="line">    <span class="type">int</span>			n_nchildren;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">node</span>	*<span class="title">n_child</span>;</span></span><br><span class="line">&#125; node;</span><br></pre></td></tr></table></figure>

<p>调用 PyParser_ParseFileFlagsEx 构建完 AST 树之后，会调用 PyAST_FromNode 将其解析为 mod：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> file_input:</span><br><span class="line">    stmts = asdl_seq_new(num_stmts(n), arena);</span><br><span class="line">    <span class="keyword">if</span> (!stmts)</span><br><span class="line">    	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; NCH(n) - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        ch = CHILD(n, i);</span><br><span class="line">        <span class="keyword">if</span> (TYPE(ch) == NEWLINE)</span><br><span class="line">        	<span class="keyword">continue</span>;</span><br><span class="line">        REQ(ch, stmt);</span><br><span class="line">        num = num_stmts(ch);</span><br><span class="line">        <span class="keyword">if</span> (num == <span class="number">1</span>) &#123;</span><br><span class="line">            s = ast_for_stmt(&amp;c, ch);</span><br><span class="line">            <span class="keyword">if</span> (!s)</span><br><span class="line">            	<span class="keyword">goto</span> error;</span><br><span class="line">            asdl_seq_SET(stmts, k++, s);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            ch = CHILD(ch, <span class="number">0</span>);</span><br><span class="line">            REQ(ch, simple_stmt);</span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; num; j++) &#123;</span><br><span class="line">                s = ast_for_stmt(&amp;c, CHILD(ch, j * <span class="number">2</span>));</span><br><span class="line">                <span class="keyword">if</span> (!s)</span><br><span class="line">                	<span class="keyword">goto</span> error;</span><br><span class="line">                asdl_seq_SET(stmts, k++, s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Module(stmts, arena);</span><br></pre></td></tr></table></figure>

<p>ast_for_stmt 是个 switch：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (TYPE(n) == stmt) &#123;</span><br><span class="line">        assert(NCH(n) == <span class="number">1</span>);</span><br><span class="line">        n = CHILD(n, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (TYPE(n) == simple_stmt) &#123;</span><br><span class="line">        assert(num_stmts(n) == <span class="number">1</span>);</span><br><span class="line">        n = CHILD(n, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (TYPE(n) == small_stmt) &#123;</span><br><span class="line">        n = CHILD(n, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">/* small_stmt: expr_stmt | print_stmt  | del_stmt | pass_stmt</span></span><br><span class="line"><span class="comment">                     | flow_stmt | import_stmt | global_stmt | exec_stmt</span></span><br><span class="line"><span class="comment">                     | assert_stmt</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">switch</span> (TYPE(n)) &#123;</span><br><span class="line">            <span class="keyword">case</span> expr_stmt:</span><br><span class="line">                <span class="keyword">return</span> ast_for_expr_stmt(c, n);</span><br><span class="line">            <span class="keyword">case</span> print_stmt:</span><br><span class="line">                <span class="keyword">return</span> ast_for_print_stmt(c, n);</span><br><span class="line">            ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对各种语句调用专门的处理函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> stmt_ty</span><br><span class="line"><span class="title function_">ast_for_print_stmt</span><span class="params">(<span class="keyword">struct</span> compiling *c, <span class="type">const</span> node *n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* print_stmt: &#x27;print&#x27; ( [ test (&#x27;,&#x27; test)* [&#x27;,&#x27;] ]</span></span><br><span class="line"><span class="comment">                             | &#x27;&gt;&gt;&#x27; test [ (&#x27;,&#x27; test)+ [&#x27;,&#x27;] ] )</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    expr_ty dest = <span class="literal">NULL</span>, expression;</span><br><span class="line">    asdl_seq *seq = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">bool</span> nl;</span><br><span class="line">    <span class="type">int</span> i, j, values_count, start = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    REQ(n, print_stmt);</span><br><span class="line">    <span class="keyword">if</span> (NCH(n) &gt;= <span class="number">2</span> &amp;&amp; TYPE(CHILD(n, <span class="number">1</span>)) == RIGHTSHIFT) &#123;</span><br><span class="line">        dest = ast_for_expr(c, CHILD(n, <span class="number">2</span>));</span><br><span class="line">        <span class="keyword">if</span> (!dest)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        start = <span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    values_count = (NCH(n) + <span class="number">1</span> - start) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (values_count) &#123;</span><br><span class="line">        seq = asdl_seq_new(values_count, c-&gt;c_arena);</span><br><span class="line">        <span class="keyword">if</span> (!seq)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">for</span> (i = start, j = <span class="number">0</span>; i &lt; NCH(n); i += <span class="number">2</span>, ++j) &#123;</span><br><span class="line">            expression = ast_for_expr(c, CHILD(n, i));</span><br><span class="line">            <span class="keyword">if</span> (!expression)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">            asdl_seq_SET(seq, j, expression);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    nl = (TYPE(CHILD(n, NCH(n) - <span class="number">1</span>)) == COMMA) ? <span class="literal">false</span> : <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> Print(dest, seq, nl, LINENO(n), n-&gt;n_col_offset, c-&gt;c_arena);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>简单来说就是对接受的每个 test 调用 ast_for_expr，将解析出的表达式放入 seq，表达式结构体太复杂就不放了，最后返回一个 stmt_ty：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">stmt_ty</span><br><span class="line"><span class="title function_">Print</span><span class="params">(expr_ty dest, asdl_seq * values, <span class="type">bool</span> nl, <span class="type">int</span> lineno, <span class="type">int</span> col_offset,</span></span><br><span class="line"><span class="params">      PyArena *arena)</span></span><br><span class="line">&#123;</span><br><span class="line">        stmt_ty p;</span><br><span class="line">        p = (stmt_ty)PyArena_Malloc(arena, <span class="keyword">sizeof</span>(*p));</span><br><span class="line">        <span class="keyword">if</span> (!p)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        p-&gt;kind = Print_kind;</span><br><span class="line">        p-&gt;v.Print.dest = dest;</span><br><span class="line">        p-&gt;v.Print.values = values;</span><br><span class="line">        p-&gt;v.Print.nl = nl;</span><br><span class="line">        p-&gt;lineno = lineno;</span><br><span class="line">        p-&gt;col_offset = col_offset;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再将这些 stmt 集合起来放入 mod_ty：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mod_ty</span><br><span class="line"><span class="title function_">Module</span><span class="params">(asdl_seq * body, PyArena *arena)</span></span><br><span class="line">&#123;</span><br><span class="line">        mod_ty p;</span><br><span class="line">        p = (mod_ty)PyArena_Malloc(arena, <span class="keyword">sizeof</span>(*p));</span><br><span class="line">        <span class="keyword">if</span> (!p)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        p-&gt;kind = Module_kind;</span><br><span class="line">        p-&gt;v.Module.body = body;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用 run_mod 将 mod 编译为 PyCodeObject 并执行：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line"><span class="title function_">run_mod</span><span class="params">(mod_ty mod, <span class="type">const</span> <span class="type">char</span> *filename, PyObject *globals, PyObject *locals,</span></span><br><span class="line"><span class="params">         PyCompilerFlags *flags, PyArena *arena)</span></span><br><span class="line">&#123;</span><br><span class="line">    PyCodeObject *co;</span><br><span class="line">    PyObject *v;</span><br><span class="line">    co = PyAST_Compile(mod, filename, flags, arena);</span><br><span class="line">    <span class="keyword">if</span> (co == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    v = PyEval_EvalCode(co, globals, locals);</span><br><span class="line">    Py_DECREF(co);</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>PyCodeObject 实际上是 python 字节码类，除了要执行的字节码还要很多其他信息，比如变量常量等：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Bytecode object */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    PyObject_HEAD</span><br><span class="line">    <span class="type">int</span> co_argcount;		<span class="comment">/* #arguments, except *args */</span></span><br><span class="line">    <span class="type">int</span> co_nlocals;		<span class="comment">/* #local variables */</span></span><br><span class="line">    <span class="type">int</span> co_stacksize;		<span class="comment">/* #entries needed for evaluation stack */</span></span><br><span class="line">    <span class="type">int</span> co_flags;		<span class="comment">/* CO_..., see below */</span></span><br><span class="line">    PyObject *co_code;		<span class="comment">/* instruction opcodes */</span></span><br><span class="line">    PyObject *co_consts;	<span class="comment">/* list (constants used) */</span></span><br><span class="line">    PyObject *co_names;		<span class="comment">/* list of strings (names used) */</span></span><br><span class="line">    PyObject *co_varnames;	<span class="comment">/* tuple of strings (local variable names) */</span></span><br><span class="line">    PyObject *co_freevars;	<span class="comment">/* tuple of strings (free variable names) */</span></span><br><span class="line">    PyObject *co_cellvars;      <span class="comment">/* tuple of strings (cell variable names) */</span></span><br><span class="line">    <span class="comment">/* The rest doesn&#x27;t count for hash/cmp */</span></span><br><span class="line">    PyObject *co_filename;	<span class="comment">/* string (where it was loaded from) */</span></span><br><span class="line">    PyObject *co_name;		<span class="comment">/* string (name, for reference) */</span></span><br><span class="line">    <span class="type">int</span> co_firstlineno;		<span class="comment">/* first source line number */</span></span><br><span class="line">    PyObject *co_lnotab;	<span class="comment">/* string (encoding addr&lt;-&gt;lineno mapping) See</span></span><br><span class="line"><span class="comment">				   Objects/lnotab_notes.txt for details. */</span></span><br><span class="line">    <span class="type">void</span> *co_zombieframe;     <span class="comment">/* for optimization only (see frameobject.c) */</span></span><br><span class="line">    PyObject *co_weakreflist;   <span class="comment">/* to support weakrefs to code objects */</span></span><br><span class="line">&#125; PyCodeObject;</span><br></pre></td></tr></table></figure>

<p>编译 mod 的过程在 compiler_body 函数中，之后会调用 VISIT，展开后则是 compiler_visit_stmt，然后 switch 找到 print 的变异函数 compiler_print：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">compiler_print(<span class="keyword">struct</span> compiler *c, stmt_ty s)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i, n;</span><br><span class="line">    <span class="type">bool</span> dest;</span><br><span class="line"></span><br><span class="line">    assert(s-&gt;kind == Print_kind);</span><br><span class="line">    n = asdl_seq_LEN(s-&gt;v.Print.values);</span><br><span class="line">    dest = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (s-&gt;v.Print.dest) &#123;</span><br><span class="line">        VISIT(c, expr, s-&gt;v.Print.dest);</span><br><span class="line">        dest = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        expr_ty e = (expr_ty)asdl_seq_GET(s-&gt;v.Print.values, i);</span><br><span class="line">        <span class="keyword">if</span> (dest) &#123;</span><br><span class="line">            ADDOP(c, DUP_TOP);</span><br><span class="line">            VISIT(c, expr, e);</span><br><span class="line">            ADDOP(c, ROT_TWO);</span><br><span class="line">            ADDOP(c, PRINT_ITEM_TO);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            VISIT(c, expr, e);</span><br><span class="line">            ADDOP(c, PRINT_ITEM);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (s-&gt;v.Print.nl) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dest)</span><br><span class="line">            ADDOP(c, PRINT_NEWLINE_TO)</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            ADDOP(c, PRINT_NEWLINE)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (dest)</span><br><span class="line">        ADDOP(c, POP_TOP);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到这里构造了字节码指令，VISIT(c, expr, e) 访问的是要打印的数字 1，这里会添加一个指令 LOAD_CONST，之后就是 PRINT_ITEM 和 PRINT_NEWLINE 以及结束指令。我们可以通过 python 的 dis 模块进行查看：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; dis.dis(co)</span><br><span class="line">  1           0 LOAD_CONST               0 (1)</span><br><span class="line">              3 PRINT_ITEM          </span><br><span class="line">              4 PRINT_NEWLINE       </span><br><span class="line">              5 LOAD_CONST               1 (None)</span><br><span class="line">              8 RETURN_VALUE        </span><br></pre></td></tr></table></figure>

<h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>理了一遍 python 的编译分析，可以发现跟 PHP 大同小异。</p>
<hr>
<p>Orz</p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/Web/" class="print-no-link">#Web</a>
      
        <a href="/tags/Python/" class="print-no-link">#Python</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>Python从编译到执行</div>
      <div>http://yoursite.com/2020/06/16/Python从编译到执行/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Aluvion</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2020年6月16日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2020/06/23/%E5%AE%89%E8%A3%85vld%E6%89%A9%E5%B1%95%E6%9F%A5%E7%9C%8Bopcode/" title="安装vld扩展查看opcode">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">安装vld扩展查看opcode</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2020/06/08/PHP%E4%BB%8E%E7%BC%96%E8%AF%91%E5%88%B0%E6%89%A7%E8%A1%8C/" title="PHP从编译到执行">
                        <span class="hidden-mobile">PHP从编译到执行</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
