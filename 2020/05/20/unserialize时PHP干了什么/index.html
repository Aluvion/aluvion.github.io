

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/css/images/bg/favicon.ico">
  <link rel="icon" href="/css/images/bg/favicon.ico">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Aluvion">
  <meta name="keywords" content="">
  
    <meta name="description" content="前言想研究一下 PHP 的 unserialize 流程的想法是从网鼎杯的一道 PHP 反序列化题开始的，当时发现本地 public 序列化的字段可以在远程反序列化成 protected，就觉得很神奇，于是计划阅读源码跟进一下。 本文主要侧重类的非静态成员变量。">
<meta property="og:type" content="article">
<meta property="og:title" content="unserialize时PHP干了什么">
<meta property="og:url" content="http://yoursite.com/2020/05/20/unserialize%E6%97%B6PHP%E5%B9%B2%E4%BA%86%E4%BB%80%E4%B9%88/index.html">
<meta property="og:site_name" content="Twings">
<meta property="og:description" content="前言想研究一下 PHP 的 unserialize 流程的想法是从网鼎杯的一道 PHP 反序列化题开始的，当时发现本地 public 序列化的字段可以在远程反序列化成 protected，就觉得很神奇，于是计划阅读源码跟进一下。 本文主要侧重类的非静态成员变量。">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2020-05-20T13:23:40.000Z">
<meta property="article:modified_time" content="2022-04-15T13:51:10.691Z">
<meta property="article:author" content="Aluvion">
<meta property="article:tag" content="Web">
<meta property="article:tag" content="PHP">
<meta name="twitter:card" content="summary_large_image">
  
  
  
  <title>unserialize时PHP干了什么 - Twings</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"yoursite.com","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 7.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Fluid</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/css/images/bg/bg5.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="unserialize时PHP干了什么"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2020-05-20 21:23" pubdate>
          2020年5月20日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          4.8k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          41 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">unserialize时PHP干了什么</h1>
            
            
              <div class="markdown-body">
                
                <h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>想研究一下 PHP 的 unserialize 流程的想法是从网鼎杯的一道 PHP 反序列化题开始的，当时发现本地 public 序列化的字段可以在远程反序列化成 protected，就觉得很神奇，于是计划阅读源码跟进一下。</p>
<p>本文主要侧重类的非静态成员变量。</p>
<span id="more"></span>

<hr>
<h3 id="测试用类"><a href="#测试用类" class="headerlink" title="测试用类"></a>测试用类</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Twings</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$a</span> = <span class="string">&quot;Aluvion&quot;</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="variable">$b</span> = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="variable">$c</span> = <span class="keyword">array</span>(<span class="string">&quot;PHP&quot;</span>, <span class="string">&quot;Java&quot;</span>, <span class="number">7</span>);</span><br><span class="line">    <span class="keyword">private</span> String <span class="variable">$d</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="class"><a href="#class" class="headerlink" title="class"></a>class</h3><h4 id="class-的编译及成员变量类型检测"><a href="#class-的编译及成员变量类型检测" class="headerlink" title="class 的编译及成员变量类型检测"></a>class 的编译及成员变量类型检测</h4><p>php 代码的词法分析略，这部分太长了，直接到解析 AST，获取成员变量数据进行检测的部分，在 zend_compile.c 的 zend_compile_prop_decl 函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">zend_compile_prop_decl</span><span class="params">(zend_ast *ast, zend_ast *type_ast, <span class="type">uint32_t</span> flags)</span> <span class="comment">/* &#123;&#123;&#123; */</span></span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">if</span> (ce-&gt;ce_flags &amp; ZEND_ACC_INTERFACE) &#123;</span><br><span class="line">		zend_error_noreturn(E_COMPILE_ERROR, <span class="string">&quot;Interfaces may not include member variables&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (flags &amp; ZEND_ACC_ABSTRACT) &#123;</span><br><span class="line">		zend_error_noreturn(E_COMPILE_ERROR, <span class="string">&quot;Properties cannot be declared abstract&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; children; ++i) &#123;</span><br><span class="line">		...</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (type_ast) &#123;</span><br><span class="line">			type = zend_compile_typename(type_ast, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (ZEND_TYPE_CODE(type) == IS_VOID || ZEND_TYPE_CODE(type) == IS_CALLABLE) &#123;</span><br><span class="line">				zend_error_noreturn(E_COMPILE_ERROR,</span><br><span class="line">					<span class="string">&quot;Property %s::$%s cannot have type %s&quot;</span>,</span><br><span class="line">					ZSTR_VAL(ce-&gt;name),</span><br><span class="line">					ZSTR_VAL(name),</span><br><span class="line">					zend_get_type_by_const(ZEND_TYPE_CODE(type)));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Doc comment has been appended as last element in ZEND_AST_PROP_ELEM ast */</span></span><br><span class="line">		...</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (flags &amp; ZEND_ACC_FINAL) &#123;</span><br><span class="line">			...</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (zend_hash_exists(&amp;ce-&gt;properties_info, name)) &#123;</span><br><span class="line">			...</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (value_ast) &#123;</span><br><span class="line">			zend_const_expr_to_zval(&amp;value_zv, value_ast);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (ZEND_TYPE_IS_SET(type) &amp;&amp; !Z_CONSTANT(value_zv)) &#123;</span><br><span class="line">				<span class="keyword">if</span> (Z_TYPE(value_zv) == IS_NULL) &#123;</span><br><span class="line">					<span class="keyword">if</span> (!ZEND_TYPE_ALLOW_NULL(type)) &#123;</span><br><span class="line">						...</span><br><span class="line">					&#125;</span><br><span class="line">				&#125; <span class="keyword">else</span> <span class="keyword">if</span> (ZEND_TYPE_IS_CLASS(type)) &#123;</span><br><span class="line">					...</span><br><span class="line">				&#125; <span class="keyword">else</span> <span class="keyword">if</span> (ZEND_TYPE_CODE(type) == IS_ARRAY || ZEND_TYPE_CODE(type) == IS_ITERABLE) &#123;</span><br><span class="line">					<span class="keyword">if</span> (Z_TYPE(value_zv) != IS_ARRAY) &#123;</span><br><span class="line">						...</span><br><span class="line">					&#125;</span><br><span class="line">				&#125; <span class="keyword">else</span> <span class="keyword">if</span> (ZEND_TYPE_CODE(type) == IS_DOUBLE) &#123;</span><br><span class="line">					<span class="keyword">if</span> (Z_TYPE(value_zv) != IS_DOUBLE &amp;&amp; Z_TYPE(value_zv) != IS_LONG) &#123;</span><br><span class="line">						...</span><br><span class="line">					&#125;</span><br><span class="line">					convert_to_double(&amp;value_zv);</span><br><span class="line">				&#125; <span class="keyword">else</span> <span class="keyword">if</span> (!ZEND_SAME_FAKE_TYPE(ZEND_TYPE_CODE(type), Z_TYPE(value_zv))) &#123;</span><br><span class="line">					...</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (!ZEND_TYPE_IS_SET(type)) &#123;</span><br><span class="line">			ZVAL_NULL(&amp;value_zv);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			ZVAL_UNDEF(&amp;value_zv);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		zend_declare_typed_property(ce, name, &amp;value_zv, flags, doc_comment, type);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>flags 指成员变量的修饰符(如 public、protected、private)，不合法的修饰符(如 final)会在这里检测并抛出错误。</p>
<p>type 是从 type_ast 里面解析出来的指成员变量的类型，这里的类型是在 PHP 代码里面规定好的类型，没有规定类型的成员变量的 type 为 0，同样也有不合法类型的检测(如 void)。顺便在这里贴一个 PHP 底层类型的定义，这里的 type 是内部定义好的代表类型的数字 x4 之后的结果：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* regular data types */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IS_UNDEF					0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IS_NULL						1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IS_FALSE					2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IS_TRUE						3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IS_LONG						4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IS_DOUBLE					5</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IS_STRING					6</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IS_ARRAY					7</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IS_OBJECT					8</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IS_RESOURCE					9</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IS_REFERENCE				10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* constant expressions */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IS_CONSTANT_AST				11</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* internal types */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IS_INDIRECT             	13</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IS_PTR						14</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IS_ALIAS_PTR				15</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IS_ERROR					15</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* fake types used only for type hinting (Z_TYPE(zv) can not use them) */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IS_BOOL					16</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IS_CALLABLE					17</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IS_ITERABLE					18</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IS_VOID						19</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IS_NUMBER					20</span></span><br></pre></td></tr></table></figure>

<p>成员变量重复定义的检测是通过查询类里面的哈希表 properties_info 实现的，这个哈希表在后面创建的时候再说。</p>
<p>value_zv 是从 value_ast 里面解析出来的成员变量的默认值。这里会有更详细的变量类型的检测，具体什么样的是不合法的类型可以自行阅读源码，宏定义配合报错信息很容易理解。这里提一下两个宏：ZEND_TYPE_IS_SET 和 ZEND_TYPE_CODE，ZEND_TYPE_IS_SET 虽然叫 is，其实是个 &gt; 3 的比较，在规定的类型里面除了未定义其他类型都会返回 true，而 ZEND_TYPE_CODE 是个将 type &#x2F; 4 转换成内部定义数字的宏。</p>
<p>完成检测之后，会调用 zend_declare_typed_property 函数写入内存。</p>
<h4 id="class-结构体"><a href="#class-结构体" class="headerlink" title="class 结构体"></a>class 结构体</h4><p>class 在 PHP 内存中是一个 _zend_class_entry 结构体：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">zend_class_entry</span> &#123;</span></span><br><span class="line">	<span class="type">char</span> type;</span><br><span class="line">	zend_string *name;</span><br><span class="line">	<span class="comment">/* class_entry or string depending on ZEND_ACC_LINKED */</span></span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">		zend_class_entry *parent;</span><br><span class="line">		zend_string *parent_name;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="type">int</span> refcount;</span><br><span class="line">	<span class="type">uint32_t</span> ce_flags;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> default_properties_count;</span><br><span class="line">	<span class="type">int</span> default_static_members_count;</span><br><span class="line">	zval *default_properties_table;</span><br><span class="line">	zval *default_static_members_table;</span><br><span class="line">	ZEND_MAP_PTR_DEF(zval *, static_members_table);</span><br><span class="line">	HashTable function_table;</span><br><span class="line">	HashTable properties_info;</span><br><span class="line">	HashTable constants_table;</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> _<span class="title">zend_property_info</span> **<span class="title">properties_info_table</span>;</span></span><br><span class="line"></span><br><span class="line">	zend_function *constructor;</span><br><span class="line">	zend_function *destructor;</span><br><span class="line">	zend_function *clone;</span><br><span class="line">	zend_function *__get;</span><br><span class="line">	zend_function *__set;</span><br><span class="line">	zend_function *__unset;</span><br><span class="line">	zend_function *__isset;</span><br><span class="line">	zend_function *__call;</span><br><span class="line">	zend_function *__callstatic;</span><br><span class="line">	zend_function *__tostring;</span><br><span class="line">	zend_function *__debugInfo;</span><br><span class="line">	zend_function *serialize_func;</span><br><span class="line">	zend_function *unserialize_func;</span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>本类和父类的各种信息、各种魔术方法和静态成员变量暂且不提，可以看到跟非静态成员变量相关的数据主要是这几个：</p>
<ul>
<li>default_properties_count</li>
<li>default_properties_table</li>
<li>properties_info</li>
<li>properties_info_table</li>
</ul>
<h4 id="成员变量写入内存"><a href="#成员变量写入内存" class="headerlink" title="成员变量写入内存"></a>成员变量写入内存</h4><p>继续看代码，将非静态成员变量写入用户类的关键代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">ZEND_API <span class="type">int</span> <span class="title function_">zend_declare_typed_property</span><span class="params">(zend_class_entry *ce, zend_string *name, zval *property, <span class="type">int</span> access_type, zend_string *doc_comment, zend_type type)</span> <span class="comment">/* &#123;&#123;&#123; */</span></span><br><span class="line">&#123;</span><br><span class="line">	zend_property_info *property_info, *property_info_ptr;</span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line">	property_info = zend_arena_alloc(&amp;CG(arena), <span class="keyword">sizeof</span>(zend_property_info));</span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!(access_type &amp; ZEND_ACC_PPP_MASK)) &#123;</span><br><span class="line">		access_type |= ZEND_ACC_PUBLIC;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (access_type &amp; ZEND_ACC_STATIC) &#123;</span><br><span class="line">		...</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		zval *property_default_ptr;</span><br><span class="line">		<span class="keyword">if</span> ((property_info_ptr = zend_hash_find_ptr(&amp;ce-&gt;properties_info, name)) != <span class="literal">NULL</span> &amp;&amp;</span><br><span class="line">		    (property_info_ptr-&gt;flags &amp; ZEND_ACC_STATIC) == <span class="number">0</span>) &#123;</span><br><span class="line">			...</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			property_info-&gt;offset = OBJ_PROP_TO_OFFSET(ce-&gt;default_properties_count);</span><br><span class="line">			ce-&gt;default_properties_count++;</span><br><span class="line">			ce-&gt;default_properties_table = perealloc(ce-&gt;default_properties_table, <span class="keyword">sizeof</span>(zval) * ce-&gt;default_properties_count, ce-&gt;type == ZEND_INTERNAL_CLASS);</span><br><span class="line"></span><br><span class="line">			<span class="comment">/* For user classes this is handled during linking */</span></span><br><span class="line">			<span class="keyword">if</span> (ce-&gt;type == ZEND_INTERNAL_CLASS) &#123;</span><br><span class="line">				...</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		property_default_ptr = &amp;ce-&gt;default_properties_table[OBJ_PROP_TO_NUM(property_info-&gt;offset)];</span><br><span class="line">		ZVAL_COPY_VALUE(property_default_ptr, property);</span><br><span class="line">		Z_PROP_FLAG_P(property_default_ptr) = Z_ISUNDEF_P(property) ? IS_PROP_UNINIT : <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (ce-&gt;type &amp; ZEND_INTERNAL_CLASS) &#123;</span><br><span class="line">		...</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (access_type &amp; ZEND_ACC_PUBLIC) &#123;</span><br><span class="line">		property_info-&gt;name = zend_string_copy(name);</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (access_type &amp; ZEND_ACC_PRIVATE) &#123;</span><br><span class="line">		property_info-&gt;name = zend_mangle_property_name(ZSTR_VAL(ce-&gt;name), ZSTR_LEN(ce-&gt;name), ZSTR_VAL(name), ZSTR_LEN(name), is_persistent_class(ce));</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		ZEND_ASSERT(access_type &amp; ZEND_ACC_PROTECTED);</span><br><span class="line">		property_info-&gt;name = zend_mangle_property_name(<span class="string">&quot;*&quot;</span>, <span class="number">1</span>, ZSTR_VAL(name), ZSTR_LEN(name), is_persistent_class(ce));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	property_info-&gt;name = zend_new_interned_string(property_info-&gt;name);</span><br><span class="line">	property_info-&gt;flags = access_type;</span><br><span class="line">	property_info-&gt;doc_comment = doc_comment;</span><br><span class="line">	property_info-&gt;ce = ce;</span><br><span class="line">	property_info-&gt;type = type;</span><br><span class="line"></span><br><span class="line">	zend_hash_update_ptr(&amp;ce-&gt;properties_info, name, property_info);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不符合 public、protected、private 的变量修饰符会变成 public。</p>
<p>然后开始将非静态成员变量的数据写入内存，首先需要一个计算非静态成员变量数目的变量，也就是 default_properties_count，然后是计算 offset。</p>
<p>先说一下非静态成员变量的存放方式，非静态成员变量的值存放在 default_properties_table，其它信息则是先存放在 property_info，最后会更新到哈希表 properties_info 里面。property_info 的结构如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">zend_property_info</span> &#123;</span></span><br><span class="line">	<span class="type">uint32_t</span> offset; <span class="comment">/* property offset for object properties or</span></span><br><span class="line"><span class="comment">	                      property index for static properties */</span></span><br><span class="line">	<span class="type">uint32_t</span> flags;</span><br><span class="line">	zend_string *name;</span><br><span class="line">	zend_string *doc_comment;</span><br><span class="line">	zend_class_entry *ce;</span><br><span class="line">	zend_type type;</span><br><span class="line">&#125; zend_property_info;</span><br></pre></td></tr></table></figure>

<p>flags 修饰符等标识，其他数据都好理解，而 offset 用来表示内存中对象的成员变量距离头部的偏移：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> OBJ_PROP_TO_OFFSET(num) ((uint32_t)(XtOffsetOf(zend_object, properties_table) + sizeof(zval) * (num)))</span></span><br></pre></td></tr></table></figure>

<p>所以 offset 就是 0x28 + 0x10 * default_properties_count，有什么用途以后再说。</p>
<p>然后将 property(即代表成员变量值的 zval，包括类型和值两个数据)复制到 default_properties_table 的相应位置上，default_properties_table 实质上就是一个 zval 数组。</p>
<p>接下里则是将成员变量的相关信息存放进 property_info 里面，首先是按照修饰符修改成员变量名，public 不改，protected 加上 \x00*\x00，private 加上 \x00类名\x00，就编程了我们在序列化字符串中看到的样子。然后则是将修饰符、类指针、规定的变量类型都放入 property_info，最后调用 zend_hash_update_ptr 将其更新到哈希表 properties_info 中，哈希表的结构如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">Bucket</span> &#123;</span></span><br><span class="line">	zval              val;</span><br><span class="line">	zend_ulong        h;                <span class="comment">/* hash value (or numeric index)   */</span></span><br><span class="line">	zend_string      *key;              <span class="comment">/* string key or NULL for numerics */</span></span><br><span class="line">&#125; Bucket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">zend_array</span> <span class="title">HashTable</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">zend_array</span> &#123;</span></span><br><span class="line">	zend_refcounted_h gc;</span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">			ZEND_ENDIAN_LOHI_4(</span><br><span class="line">				zend_uchar    flags,</span><br><span class="line">				zend_uchar    _unused,</span><br><span class="line">				zend_uchar    nIteratorsCount,</span><br><span class="line">				zend_uchar    _unused2)</span><br><span class="line">		&#125; v;</span><br><span class="line">		<span class="type">uint32_t</span> flags;</span><br><span class="line">	&#125; u;</span><br><span class="line">	<span class="type">uint32_t</span>          nTableMask;</span><br><span class="line">	Bucket           *arData;</span><br><span class="line">	<span class="type">uint32_t</span>          nNumUsed;</span><br><span class="line">	<span class="type">uint32_t</span>          nNumOfElements;</span><br><span class="line">	<span class="type">uint32_t</span>          nTableSize;</span><br><span class="line">	<span class="type">uint32_t</span>          nInternalPointer;</span><br><span class="line">	zend_long         nNextFreeElement;</span><br><span class="line">	<span class="type">dtor_func_t</span>       pDestructor;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>数据存放在 arData 中，数量则用 nNumUsed 记录。如 property_info 就是作为一个 ptr 类型的数据存放在 val 中，key 则是根据修饰符修改前的变量名，h 是根据 key 生成的一个哈希。</p>
<p>至此，类非静态成员变量的处理及相关的 default_properties_count、default_properties_table、properties_info 等结构体成员的构成都大致清楚了，非静态成员变量相关的数据已经基本齐全，剩下的 properties_info_table 其实跟 properties_info 的数据存在重复，具体可以看 zend_build_properties_info_table 函数，它其实就是存放在 properties_info 里的 property_info。</p>
<p>他们的区别就在于 properties_info 存放了根据修饰符修改前的变量名，所以可以通过偏移和查找 key 来访问，而 properties_info_table 只可以通过偏移来访问。但是 properties_info_table 也有一个优点，那就是结构比较简单，可以直接查找该变量的规定类型(如 zend_get_typed_property_info_for_slot 函数)。</p>
<p>顺带一提，在继承的情况下，在分析编译完字类之后，要将父类的数据继承到字类，即按照父类对字类做一些修改，修改的逻辑在 zend_do_inheritance_ex 函数中。如果重写了父类的成员变量，修改后字类的 default_properties_count、default_properties_table 和 properties_info 属性都会改变，前两者加上父类的相应数据，复制到一个新的 zval 数组里再赋值回 default_properties_table，不知道为什么是倒着来复制的，子类的放在后面：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (parent_ce-&gt;default_properties_count) &#123;</span><br><span class="line">    <span class="keyword">if</span> (ce-&gt;default_properties_count) &#123;</span><br><span class="line">        zval *table = pemalloc(<span class="keyword">sizeof</span>(zval) * (ce-&gt;default_properties_count + parent_ce-&gt;default_properties_count), ce-&gt;type == ZEND_INTERNAL_CLASS);</span><br><span class="line">        src = ce-&gt;default_properties_table + ce-&gt;default_properties_count;</span><br><span class="line">        end = table + parent_ce-&gt;default_properties_count;</span><br><span class="line">        dst = end + ce-&gt;default_properties_count;</span><br><span class="line">        ce-&gt;default_properties_table = table;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            dst--;</span><br><span class="line">            src--;</span><br><span class="line">        ZVAL_COPY_VALUE_PROP(dst, src);</span><br><span class="line">        &#125; <span class="keyword">while</span> (dst != end);</span><br><span class="line">        pefree(src, ce-&gt;type == ZEND_INTERNAL_CLASS);</span><br><span class="line">        end = ce-&gt;default_properties_table;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    src = parent_ce-&gt;default_properties_table + parent_ce-&gt;default_properties_count;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        dst--;</span><br><span class="line">        src--;</span><br><span class="line">        ZVAL_COPY_PROP(dst, src);</span><br><span class="line">        <span class="keyword">if</span> (Z_OPT_TYPE_P(dst) == IS_CONSTANT_AST) &#123;</span><br><span class="line">            ce-&gt;ce_flags &amp;= ~ZEND_ACC_CONSTANTS_UPDATED;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125; <span class="keyword">while</span> (dst != end);</span><br><span class="line">    ce-&gt;default_properties_count += parent_ce-&gt;default_properties_count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>properties_info 的处理如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">ZEND_HASH_FOREACH_PTR(&amp;ce-&gt;properties_info, property_info) &#123;</span><br><span class="line">    <span class="keyword">if</span> (property_info-&gt;ce == ce) &#123;</span><br><span class="line">        <span class="keyword">if</span> (property_info-&gt;flags &amp; ZEND_ACC_STATIC) &#123;</span><br><span class="line">            property_info-&gt;offset += parent_ce-&gt;default_static_members_count;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            property_info-&gt;offset += parent_ce-&gt;default_properties_count * <span class="keyword">sizeof</span>(zval);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; ZEND_HASH_FOREACH_END();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (zend_hash_num_elements(&amp;parent_ce-&gt;properties_info)) &#123;</span><br><span class="line">    zend_hash_extend(&amp;ce-&gt;properties_info,</span><br><span class="line">        zend_hash_num_elements(&amp;ce-&gt;properties_info) +</span><br><span class="line">        zend_hash_num_elements(&amp;parent_ce-&gt;properties_info), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    ZEND_HASH_FOREACH_STR_KEY_PTR(&amp;parent_ce-&gt;properties_info, key, property_info) &#123;</span><br><span class="line">    	do_inherit_property(property_info, key, ce);</span><br><span class="line">    &#125; ZEND_HASH_FOREACH_END();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主要有两个部分，首先是遍历字类的 properties_info 然后修改里面 propertie_info 的偏移，因为前面复制 default_properties_table 的时候将父类的变量放在前面，所以需要加上相应的偏移。然后就是遍历父类的 properties_info，如果 key 不存在就加上去，因为父类放在前面，所以偏移不需要改变：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (UNEXPECTED(ce-&gt;type &amp; ZEND_INTERNAL_CLASS)) &#123;</span><br><span class="line">	child_info = zend_duplicate_property_info_internal(parent_info);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	child_info = parent_info;</span><br><span class="line">&#125;</span><br><span class="line">_zend_hash_append_ptr(&amp;ce-&gt;properties_info, key, child_info);</span><br></pre></td></tr></table></figure>

<p>而如果字类中存在这个 key，即重写了父类中的成员变量，而且父类中这个变量的修饰符不是 private：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (UNEXPECTED((child_info-&gt;flags &amp; ZEND_ACC_PPP_MASK) &gt; (parent_info-&gt;flags &amp; ZEND_ACC_PPP_MASK))) &#123;</span><br><span class="line">    zend_error_noreturn(...);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> ((child_info-&gt;flags &amp; ZEND_ACC_STATIC) == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="type">int</span> parent_num = OBJ_PROP_TO_NUM(parent_info-&gt;offset);</span><br><span class="line">    <span class="type">int</span> child_num = OBJ_PROP_TO_NUM(child_info-&gt;offset);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Don&#x27;t keep default properties in GC (they may be freed by opcache) */</span></span><br><span class="line">    zval_ptr_dtor_nogc(&amp;(ce-&gt;default_properties_table[parent_num]));</span><br><span class="line">    ce-&gt;default_properties_table[parent_num] = ce-&gt;default_properties_table[child_num];</span><br><span class="line">    ZVAL_UNDEF(&amp;ce-&gt;default_properties_table[child_num]);</span><br><span class="line">    child_info-&gt;offset = parent_info-&gt;offset;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (UNEXPECTED(ZEND_TYPE_IS_SET(parent_info-&gt;type))) &#123;</span><br><span class="line">    inheritance_status status = property_types_compatible(parent_info, child_info);</span><br><span class="line">    <span class="keyword">if</span> (status == INHERITANCE_ERROR) &#123;</span><br><span class="line">        emit_incompatible_property_error(child_info, parent_info);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (status == INHERITANCE_UNRESOLVED) &#123;</span><br><span class="line">        add_property_compatibility_obligation(ce, child_info, parent_info);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (UNEXPECTED(ZEND_TYPE_IS_SET(child_info-&gt;type) &amp;&amp; !ZEND_TYPE_IS_SET(parent_info-&gt;type))) &#123;</span><br><span class="line">    zend_error_noreturn(...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修饰符等级不能变大，如 protected 不能变成 private。</p>
<p>修改 default_properties_table，将字类的重复变量覆盖到前面的父类上面，修改字类该变量的偏移，然后尝试清空字类里面的多余数据。</p>
<p>最后检测父类该变量是否有规定类型，若有规定类型则检测父类和字类重复变量的类型是否能共存，具体判断就不说了。</p>
<p>如果是 private 类型就不会进行改动，但是会给字类的这个变量加上一个 ZEND_ACC_CHANGED 的标识，后面实例化的时候会有不同的处理。</p>
<h4 id="class-在内存中的存放"><a href="#class-在内存中的存放" class="headerlink" title="class 在内存中的存放"></a>class 在内存中的存放</h4><p>为了方便理解，最好一边调试一边看内存，class：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; p *ce</span><br><span class="line">$<span class="number">5</span> = &#123;</span><br><span class="line">  default_properties_count = <span class="number">4</span>, </span><br><span class="line">  default_properties_table = <span class="number">0x7ffff3e6c240</span>, </span><br><span class="line">  properties_info = &#123;</span><br><span class="line">    gc = &#123;</span><br><span class="line">      refcount = <span class="number">1</span>, </span><br><span class="line">      u = &#123;</span><br><span class="line">        type_info = <span class="number">23</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, </span><br><span class="line">    u = &#123;</span><br><span class="line">      v = &#123;</span><br><span class="line">        flags = <span class="number">16</span> <span class="string">&#x27;\020&#x27;</span>, </span><br><span class="line">        _unused = <span class="number">0</span> <span class="string">&#x27;\000&#x27;</span>, </span><br><span class="line">        nIteratorsCount = <span class="number">0</span> <span class="string">&#x27;\000&#x27;</span>, </span><br><span class="line">        _unused2 = <span class="number">0</span> <span class="string">&#x27;\000&#x27;</span></span><br><span class="line">      &#125;, </span><br><span class="line">      flags = <span class="number">16</span></span><br><span class="line">    &#125;, </span><br><span class="line">    nTableMask = <span class="number">4294967280</span>, </span><br><span class="line">    arData = <span class="number">0x7ffff3e5c7c0</span>, </span><br><span class="line">    nNumUsed = <span class="number">4</span>, </span><br><span class="line">    nNumOfElements = <span class="number">4</span>, </span><br><span class="line">    nTableSize = <span class="number">8</span>, </span><br><span class="line">    nInternalPointer = <span class="number">0</span>, </span><br><span class="line">    nNextFreeElement = <span class="number">0</span>, </span><br><span class="line">    pDestructor = <span class="number">0x0</span></span><br><span class="line">  &#125;, </span><br><span class="line">  properties_info_table = <span class="number">0x7ffff3e03368</span>, </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>default_properties_count，非静态成员变量数目。</p>
<p>default_properties_table，zval 结构体数组，前 8 字节表示值，后 8 字节表示类型等数据：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x/20xg ce-&gt;default_properties_table</span><br><span class="line">0x7ffff3e6c240:	0x00007ffff3e6b5a0	0x0000000000000006</span><br><span class="line">0x7ffff3e6c250:	0x0000000000000001	0x0000000000000004</span><br><span class="line">0x7ffff3e6c260:	0x00007ffff3e562a0	0x0000000000000307</span><br><span class="line">0x7ffff3e6c270:	0x00007ffff3e562a0	0x0000000100000000</span><br></pre></td></tr></table></figure>

<p>properties_info，长度为 4 的哈希表，arData 为 Bucket 数组，其中后 16 字节中的前 8 字节为 hash，后 8 字节为 zend_string 类型的 key：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x/20xg ce-&gt;properties_info-&gt;arData</span><br><span class="line">0x7ffff3e5c7c0:	0x00007ffff3e032c8	0xffffffff0000000e</span><br><span class="line">0x7ffff3e5c7d0:	0x800000000002b606	0x00000000016437d0</span><br><span class="line">0x7ffff3e5c7e0:	0x00007ffff3e032f0	0xffffffff0000000e</span><br><span class="line">0x7ffff3e5c7f0:	0x800000000002b607	0x0000000001643800</span><br><span class="line">0x7ffff3e5c800:	0x00007ffff3e03318	0xffffffff0000000e</span><br><span class="line">0x7ffff3e5c810:	0x800000000002b608	0x0000000001643830</span><br><span class="line">0x7ffff3e5c820:	0x00007ffff3e03340	0xffffffff0000000e</span><br><span class="line">0x7ffff3e5c830:	0x800000000002b609	0x0000000001643860</span><br></pre></td></tr></table></figure>

<p>前 16 字节为 ptr 类型的 zval，指向一个 zend_property_info 结构体：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x/20xg (zend_property_info*)ce-&gt;properties_info-&gt;arData-&gt;val-&gt;value-&gt;ptr</span><br><span class="line">0x7ffff3e032c8:	0x0000000100000028	0x00000000016437d0</span><br><span class="line">0x7ffff3e032d8:	0x0000000000000000	0x00007ffff3e03100</span><br><span class="line">0x7ffff3e032e8:	0x0000000000000000	0x0000000200000038</span><br><span class="line">0x7ffff3e032f8:	0x00007ffff3e6b640	0x0000000000000000</span><br><span class="line">0x7ffff3e03308:	0x00007ffff3e03100	0x0000000000000000</span><br><span class="line">0x7ffff3e03318:	0x0000000400000048	0x00007ffff3e01aa0</span><br><span class="line">0x7ffff3e03328:	0x0000000000000000	0x00007ffff3e03100</span><br><span class="line">0x7ffff3e03338:	0x0000000000000000	0x0000000400000058</span><br><span class="line">0x7ffff3e03348:	0x00007ffff3e01ac8	0x0000000000000000</span><br><span class="line">0x7ffff3e03358:	0x00007ffff3e03100	0x0000000000000018</span><br><span class="line">pwndbg&gt; p *(zend_property_info*)ce-&gt;properties_info-&gt;arData-&gt;val-&gt;value-&gt;ptr</span><br><span class="line">$17 = &#123;</span><br><span class="line">  offset = 40, </span><br><span class="line">  flags = 1, </span><br><span class="line">  name = 0x16437d0, </span><br><span class="line">  doc_comment = 0x0, </span><br><span class="line">  ce = 0x7ffff3e03100, </span><br><span class="line">  type = 0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>properties_info_table，指向 properties_info 内 zend_property_info 结构体的指针数组，可以对照上面的存放地址来看：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x/20xg ce-&gt;properties_info_table</span><br><span class="line">0x7ffff3e03368:	0x00007ffff3e032c8	0x00007ffff3e032f0</span><br><span class="line">0x7ffff3e03378:	0x00007ffff3e03318	0x00007ffff3e03340</span><br></pre></td></tr></table></figure>

<h4 id="class-管理"><a href="#class-管理" class="headerlink" title="class 管理"></a>class 管理</h4><p>在将一个 class 的相关数据都写入内存之后，自然需要有一个统一的管理，不然 new 的时候都不知道去哪里找这个类。PHP 底层用来管理类的就是一个哈希表 class_table，可以根据类名来查找类。class_table 存放 class 的结构大致如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; p *(Bucket*)(CG(class_table)-&gt;arData+158)</span><br><span class="line">$38 = &#123;</span><br><span class="line">  val = &#123;</span><br><span class="line">    value = &#123;</span><br><span class="line">      ptr = 0x7ffff3e03100, </span><br><span class="line">    &#125;, </span><br><span class="line">    u1 = &#123;</span><br><span class="line">      v = &#123;</span><br><span class="line">        type = 14 &#x27;\016&#x27;, </span><br><span class="line">        type_flags = 0 &#x27;\000&#x27;, </span><br><span class="line">        u = &#123;</span><br><span class="line">          extra = 0</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;, </span><br><span class="line">      type_info = 14</span><br><span class="line">    &#125;, </span><br><span class="line">  &#125;, </span><br><span class="line">  h = 9223378990928643873, </span><br><span class="line">  key = 0x7ffff3e6b520</span><br><span class="line">&#125;</span><br><span class="line">pwndbg&gt; x/10s (*(Bucket*)(CG(class_table)-&gt;arData+158))-&gt;key-&gt;val</span><br><span class="line">0x7ffff3e6b538:	&quot;twings&quot;</span><br></pre></td></tr></table></figure>

<h3 id="object"><a href="#object" class="headerlink" title="object"></a>object</h3><h4 id="object-结构体"><a href="#object-结构体" class="headerlink" title="object 结构体"></a>object 结构体</h4><p>对象结构体如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">zend_object</span> &#123;</span></span><br><span class="line">	zend_refcounted_h gc;</span><br><span class="line">	<span class="type">uint32_t</span>          handle; <span class="comment">// <span class="doctag">TODO:</span> may be removed ???</span></span><br><span class="line">	zend_class_entry *ce;</span><br><span class="line">	<span class="type">const</span> zend_object_handlers *handlers;</span><br><span class="line">	HashTable        *properties;</span><br><span class="line">	zval              properties_table[<span class="number">1</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>比类的结构体简单很多，跟成员变量相关的是 properties 和 properties_table 两个成员。</p>
<h4 id="根据类名查找类"><a href="#根据类名查找类" class="headerlink" title="根据类名查找类"></a>根据类名查找类</h4><p>PHP 底层有一个函数 zend_lookup_class_ex，可以根据类名查找类：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">ZEND_API zend_class_entry *<span class="title function_">zend_lookup_class_ex</span><span class="params">(zend_string *name, zend_string *key, <span class="type">uint32_t</span> flags)</span> <span class="comment">/* &#123;&#123;&#123; */</span></span><br><span class="line">&#123;</span><br><span class="line">	zend_class_entry *ce = <span class="literal">NULL</span>;</span><br><span class="line">	zval args[<span class="number">1</span>], *zv;</span><br><span class="line">	zval local_retval;</span><br><span class="line">	zend_string *lc_name;</span><br><span class="line">	zend_fcall_info fcall_info;</span><br><span class="line">	zend_fcall_info_cache fcall_cache;</span><br><span class="line">	zend_class_entry *orig_fake_scope;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (key) &#123;</span><br><span class="line">		lc_name = key;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (name == <span class="literal">NULL</span> || !ZSTR_LEN(name)) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (ZSTR_VAL(name)[<span class="number">0</span>] == <span class="string">&#x27;\\&#x27;</span>) &#123;</span><br><span class="line">			lc_name = zend_string_alloc(ZSTR_LEN(name) - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">			zend_str_tolower_copy(ZSTR_VAL(lc_name), ZSTR_VAL(name) + <span class="number">1</span>, ZSTR_LEN(name) - <span class="number">1</span>);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			lc_name = zend_string_tolower(name);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	zv = zend_hash_find(EG(class_table), lc_name);</span><br><span class="line">	<span class="keyword">if</span> (zv) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!key) &#123;</span><br><span class="line">			zend_string_release_ex(lc_name, <span class="number">0</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		ce = (zend_class_entry*)Z_PTR_P(zv);</span><br><span class="line">		...</span><br><span class="line">		<span class="keyword">return</span> ce;</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到命名空间 \ 处理，类名小写处理以及查询哈希表的操作，源码里的很多标识(zend_ACC_*)都可以在 zend_compile.h 里面找到定义，结合注释和标识名可以更好理解。这个函数后面还有一段查询失败后调用 autoload 来动态加载类的代码，这里就不提了。</p>
<h4 id="根据类新建对象"><a href="#根据类新建对象" class="headerlink" title="根据类新建对象"></a>根据类新建对象</h4><p>获取到类后，就要根据类来新建对象，处理代码在 _object_and_properties_init 函数中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> zend_always_inline <span class="type">int</span> _object_and_properties_init(zval *arg, zend_class_entry *class_type, HashTable *properties) <span class="comment">/* &#123;&#123;&#123; */</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (UNEXPECTED(class_type-&gt;ce_flags &amp; (ZEND_ACC_INTERFACE|ZEND_ACC_TRAIT|ZEND_ACC_IMPLICIT_ABSTRACT_CLASS|ZEND_ACC_EXPLICIT_ABSTRACT_CLASS))) &#123;</span><br><span class="line">		<span class="keyword">if</span> (class_type-&gt;ce_flags &amp; ZEND_ACC_INTERFACE) &#123;</span><br><span class="line">			zend_throw_error(<span class="literal">NULL</span>, <span class="string">&quot;Cannot instantiate interface %s&quot;</span>, ZSTR_VAL(class_type-&gt;name));</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (class_type-&gt;ce_flags &amp; ZEND_ACC_TRAIT) &#123;</span><br><span class="line">			zend_throw_error(<span class="literal">NULL</span>, <span class="string">&quot;Cannot instantiate trait %s&quot;</span>, ZSTR_VAL(class_type-&gt;name));</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			zend_throw_error(<span class="literal">NULL</span>, <span class="string">&quot;Cannot instantiate abstract class %s&quot;</span>, ZSTR_VAL(class_type-&gt;name));</span><br><span class="line">		&#125;</span><br><span class="line">		ZVAL_NULL(arg);</span><br><span class="line">		Z_OBJ_P(arg) = <span class="literal">NULL</span>;</span><br><span class="line">		<span class="keyword">return</span> FAILURE;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (UNEXPECTED(!(class_type-&gt;ce_flags &amp; ZEND_ACC_CONSTANTS_UPDATED))) &#123;</span><br><span class="line">		<span class="keyword">if</span> (UNEXPECTED(zend_update_class_constants(class_type) != SUCCESS)) &#123;</span><br><span class="line">			ZVAL_NULL(arg);</span><br><span class="line">			Z_OBJ_P(arg) = <span class="literal">NULL</span>;</span><br><span class="line">			<span class="keyword">return</span> FAILURE;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (class_type-&gt;create_object == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		zend_object *obj = zend_objects_new(class_type);</span><br><span class="line"></span><br><span class="line">		ZVAL_OBJ(arg, obj);</span><br><span class="line">		<span class="keyword">if</span> (properties) &#123;</span><br><span class="line">			object_properties_init_ex(obj, properties);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			_object_properties_init(obj, class_type);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		ZVAL_OBJ(arg, class_type-&gt;create_object(class_type));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>新建一个空白对象后，会调用 _object_properties_init 初始化成员变量：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> zend_always_inline <span class="type">void</span> _object_properties_init(zend_object *object, zend_class_entry *class_type) <span class="comment">/* &#123;&#123;&#123; */</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (class_type-&gt;default_properties_count) &#123;</span><br><span class="line">		zval *src = class_type-&gt;default_properties_table;</span><br><span class="line">		zval *dst = object-&gt;properties_table;</span><br><span class="line">		zval *end = src + class_type-&gt;default_properties_count;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (UNEXPECTED(class_type-&gt;type == ZEND_INTERNAL_CLASS)) &#123;</span><br><span class="line">			<span class="keyword">do</span> &#123;</span><br><span class="line">				ZVAL_COPY_OR_DUP_PROP(dst, src);</span><br><span class="line">				src++;</span><br><span class="line">				dst++;</span><br><span class="line">			&#125; <span class="keyword">while</span> (src != end);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">do</span> &#123;</span><br><span class="line">				ZVAL_COPY_PROP(dst, src);</span><br><span class="line">				src++;</span><br><span class="line">				dst++;</span><br><span class="line">			&#125; <span class="keyword">while</span> (src != end);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>简单来说就是遍历类的 default_properties_table，然后将其中数据复制到对象的 properties_table 中。这个时候，对象里面只有变量的值，用于根据 key 查询的 properties 哈希表还是空的，而哈希表的初始化需要调用 Z_OBJPROP_P，其实就是 object_handlers 的 zend_std_get_properties 函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">ZEND_API HashTable *<span class="title function_">zend_std_get_properties</span><span class="params">(zval *object)</span> <span class="comment">/* &#123;&#123;&#123; */</span></span><br><span class="line">&#123;</span><br><span class="line">	zend_object *zobj;</span><br><span class="line">	zobj = Z_OBJ_P(object);</span><br><span class="line">	<span class="keyword">if</span> (!zobj-&gt;properties) &#123;</span><br><span class="line">		rebuild_object_properties(zobj);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> zobj-&gt;properties;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">ZEND_API <span class="type">void</span> <span class="title function_">rebuild_object_properties</span><span class="params">(zend_object *zobj)</span> <span class="comment">/* &#123;&#123;&#123; */</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (!zobj-&gt;properties) &#123;</span><br><span class="line">		zend_property_info *prop_info;</span><br><span class="line">		zend_class_entry *ce = zobj-&gt;ce;</span><br><span class="line">		<span class="type">uint32_t</span> flags = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">		zobj-&gt;properties = zend_new_array(ce-&gt;default_properties_count);</span><br><span class="line">		<span class="keyword">if</span> (ce-&gt;default_properties_count) &#123;</span><br><span class="line">			zend_hash_real_init_mixed(zobj-&gt;properties);</span><br><span class="line">			ZEND_HASH_FOREACH_PTR(&amp;ce-&gt;properties_info, prop_info) &#123;</span><br><span class="line">				<span class="keyword">if</span> (!(prop_info-&gt;flags &amp; ZEND_ACC_STATIC)) &#123;</span><br><span class="line">					flags |= prop_info-&gt;flags;</span><br><span class="line"></span><br><span class="line">					<span class="keyword">if</span> (UNEXPECTED(Z_TYPE_P(OBJ_PROP(zobj, prop_info-&gt;offset)) == IS_UNDEF)) &#123;</span><br><span class="line">						HT_FLAGS(zobj-&gt;properties) |= HASH_FLAG_HAS_EMPTY_IND;</span><br><span class="line">					&#125;</span><br><span class="line"></span><br><span class="line">					_zend_hash_append_ind(zobj-&gt;properties, prop_info-&gt;name,</span><br><span class="line">						OBJ_PROP(zobj, prop_info-&gt;offset));</span><br><span class="line">				&#125;</span><br><span class="line">			&#125; ZEND_HASH_FOREACH_END();</span><br><span class="line">			<span class="keyword">if</span> (flags &amp; ZEND_ACC_CHANGED) &#123;</span><br><span class="line">				<span class="keyword">while</span> (ce-&gt;parent &amp;&amp; ce-&gt;parent-&gt;default_properties_count) &#123;</span><br><span class="line">					ce = ce-&gt;parent;</span><br><span class="line">					ZEND_HASH_FOREACH_PTR(&amp;ce-&gt;properties_info, prop_info) &#123;</span><br><span class="line">						<span class="keyword">if</span> (prop_info-&gt;ce == ce &amp;&amp;</span><br><span class="line">						    !(prop_info-&gt;flags &amp; ZEND_ACC_STATIC) &amp;&amp;</span><br><span class="line">						    (prop_info-&gt;flags &amp; ZEND_ACC_PRIVATE)) &#123;</span><br><span class="line">							zval zv;</span><br><span class="line"></span><br><span class="line">							<span class="keyword">if</span> (UNEXPECTED(Z_TYPE_P(OBJ_PROP(zobj, prop_info-&gt;offset)) == IS_UNDEF)) &#123;</span><br><span class="line">								HT_FLAGS(zobj-&gt;properties) |= HASH_FLAG_HAS_EMPTY_IND;</span><br><span class="line">							&#125;</span><br><span class="line"></span><br><span class="line">							ZVAL_INDIRECT(&amp;zv, OBJ_PROP(zobj, prop_info-&gt;offset));</span><br><span class="line">							zend_hash_add(zobj-&gt;properties, prop_info-&gt;name, &amp;zv);</span><br><span class="line">						&#125;</span><br><span class="line">					&#125; ZEND_HASH_FOREACH_END();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>遍历类的 properties_info，从里面取出该成员变量的变量名、标识以及在对象中存储的偏移，再根据偏移获取 properties_table 中的 zval 数据存入 properties 中，需要注意的是这里的 key 是根据修饰符修改后的 key，所以 properties 存储的其实就是 properties_table 的数据，里面没有父类的重复变量。</p>
<p>就像上文所说，在继承的情况下，如果重写了父类的私有变量，就会有一个 ZEND_ACC_CHANGED 的标识，在遍历完子类的 properties_info 之后，还会往上遍历父类的 properties_info，将父类的重复变量也放进 properties 里面。这是因为私有属性无法被继承，但是可以被父类的方法访问，所以需要保留下来。</p>
<h3 id="反序列化"><a href="#反序列化" class="headerlink" title="反序列化"></a>反序列化</h3><h4 id="反序列化数据结构体"><a href="#反序列化数据结构体" class="headerlink" title="反序列化数据结构体"></a>反序列化数据结构体</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	zend_long used_slots;</span><br><span class="line">	<span class="type">void</span> *next;</span><br><span class="line">	zval *data[VAR_ENTRIES_MAX];</span><br><span class="line">&#125; var_entries;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	zend_long used_slots;</span><br><span class="line">	<span class="type">void</span> *next;</span><br><span class="line">	zval data[VAR_DTOR_ENTRIES_MAX];</span><br><span class="line">&#125; var_dtor_entries;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">php_unserialize_data</span> &#123;</span></span><br><span class="line">	var_entries      *last;</span><br><span class="line">	var_dtor_entries *first_dtor;</span><br><span class="line">	var_dtor_entries *last_dtor;</span><br><span class="line">	HashTable        *allowed_classes;</span><br><span class="line">	HashTable        *ref_props;</span><br><span class="line">	zend_long         cur_depth;</span><br><span class="line">	zend_long         max_depth;</span><br><span class="line">	var_entries       entries;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>cur_depth、max_depth 很好理解，就是反序列化的深度和最大深度。</p>
<p>allowed_classes 也很好理解，允许反序列化的类。</p>
<p>last、entries，构成了一个类似栈链的结构，last 指向最后一个栈，entries 是第一个栈，存储反序列化过程数据。比如反序列化一个 Object，反序列化完前面 O 的部分后会将这个部分放进栈里，再去反序列化第一个 key。</p>
<p>first_dtor、last_dtor，同样是一个栈链的结构，存储反序列化中的临时变量。</p>
<p>ref_props，用来处理 PHP 的变量引用的类型问题。</p>
<h4 id="反序列化流程"><a href="#反序列化流程" class="headerlink" title="反序列化流程"></a>反序列化流程</h4><p>以 Object 为例。</p>
<h5 id="PHP-FUNCTION-unserialize"><a href="#PHP-FUNCTION-unserialize" class="headerlink" title="PHP_FUNCTION(unserialize)"></a>PHP_FUNCTION(unserialize)</h5><p>根据 options 配置反序列化参数，包括 max_depth 和 allowed_classes 等，然后调用 php_var_unserialize。</p>
<h5 id="php-var-unserialize"><a href="#php-var-unserialize" class="headerlink" title="php_var_unserialize"></a>php_var_unserialize</h5><p>调用 php_var_unserialize_internal 开始反序列化。</p>
<h5 id="php-var-unserialize-internal"><a href="#php-var-unserialize-internal" class="headerlink" title="php_var_unserialize_internal"></a>php_var_unserialize_internal</h5><p>把 rval push 进栈里，rval 是一个存储反序列化过程数据的全局变量，然后开始词法分析。</p>
<p>词法分析过程很好理解，在分析出类名之后，调用 zend_lookup_class 尝试获取类，如果获取不到则尝试调用 unserialize_callback_func 动态加载类，加载完后会再次调用 zend_lookup_class 获取类。</p>
<p>获取到内存中的类后，会判断该类是否定义了 __unserialize 函数，定义了该函数的反序列化过程与一般的类不太一样，具体过程可以看<a href="https://wiki.php.net/rfc/custom_object_serialization">这里</a>，会将类成员作为一个数组然后调用函数。然后调用 object_init_ex 实例化一个新的对象，进入 object_common 方法。</p>
<h5 id="object-common"><a href="#object-common" class="headerlink" title="object_common"></a>object_common</h5><p>如果定义了 __unserialize 函数，php 会调用 process_nested_data 方法将里面的数据反序列化为一个数组，然后跟对象一起放入栈中，在最后 php_var_unserialize_destroy 的时候调用。</p>
<p>如果没有定义，就会判断是否定义了 __wakeup，流程跟上面的一样。然后调用 Z_OBJPROP_P 建立对象的 properties 哈希表，同样调用 process_nested_data 反序列化对象内数据。</p>
<h5 id="process-nested-data"><a href="#process-nested-data" class="headerlink" title="process_nested_data"></a>process_nested_data</h5><p>首先是反序列化深度的检测，然后就开始根据对象&#x2F;数组内部数据的数量逐个反序列化。哈希表的更新都很好懂，如果该变量已经有默认值，就将它更新为空，而在向哈希表里添加数据的时候，properties_table 因为哈希表没有对应的指针，所以不会添加。这里重点说一下 string_key 里面是怎么将处理成员变量名的。</p>
<p>首先会再次调用 php_var_unserialize_internal，解析出 key，然后关注 zend_unmangle_property_name_ex 函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">ZEND_API <span class="type">int</span> <span class="title function_">zend_unmangle_property_name_ex</span><span class="params">(<span class="type">const</span> zend_string *name, <span class="type">const</span> <span class="type">char</span> **class_name, <span class="type">const</span> <span class="type">char</span> **prop_name, <span class="type">size_t</span> *prop_len)</span> <span class="comment">/* &#123;&#123;&#123; */</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">size_t</span> class_name_len;</span><br><span class="line">	<span class="type">size_t</span> anonclass_src_len;</span><br><span class="line"></span><br><span class="line">	*class_name = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!ZSTR_LEN(name) || ZSTR_VAL(name)[<span class="number">0</span>] != <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">		*prop_name = ZSTR_VAL(name);</span><br><span class="line">		<span class="keyword">if</span> (prop_len) &#123;</span><br><span class="line">			*prop_len = ZSTR_LEN(name);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> SUCCESS;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (ZSTR_LEN(name) &lt; <span class="number">3</span> || ZSTR_VAL(name)[<span class="number">1</span>] == <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">		<span class="comment">// FAILURE;</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	class_name_len = zend_strnlen(ZSTR_VAL(name) + <span class="number">1</span>, ZSTR_LEN(name) - <span class="number">2</span>);</span><br><span class="line">	<span class="keyword">if</span> (class_name_len &gt;= ZSTR_LEN(name) - <span class="number">2</span> || ZSTR_VAL(name)[class_name_len + <span class="number">1</span>] != <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">		<span class="comment">// FAILURE;</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	*class_name = ZSTR_VAL(name) + <span class="number">1</span>;</span><br><span class="line">	anonclass_src_len = zend_strnlen(*class_name + class_name_len + <span class="number">1</span>, ZSTR_LEN(name) - class_name_len - <span class="number">2</span>);</span><br><span class="line">	<span class="keyword">if</span> (class_name_len + anonclass_src_len + <span class="number">2</span> != ZSTR_LEN(name)) &#123;</span><br><span class="line">		class_name_len += anonclass_src_len + <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	*prop_name = ZSTR_VAL(name) + class_name_len + <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">if</span> (prop_len) &#123;</span><br><span class="line">		*prop_len = ZSTR_LEN(name) - class_name_len - <span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里会对词法解析出来的 key 进行拆解，如果是 public，即 key 不是 \x00 就会直接返回；然后开始拆解 key，从里面把类名扒出来，再将拆完剩下的最初的变量名放到 prop_name 里面，可以直接去类的哈希表 properties_info 里面查找这个变量在服务端的修饰符，这样变量修饰符就不会被序列化数据影响了。</p>
<p>后面就没有什么好说的了，之后会再调用 php_var_unserialize_internal，分析出变量值。反序列化结束后，会调用 php_var_unserialize_destroy，清理栈内数据，调用反序列化魔术方法。</p>
<p>整个反序列化过程其实就是个递归的过程。</p>
<hr>
<p>Orz</p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/Web/" class="print-no-link">#Web</a>
      
        <a href="/tags/PHP/" class="print-no-link">#PHP</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>unserialize时PHP干了什么</div>
      <div>http://yoursite.com/2020/05/20/unserialize时PHP干了什么/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Aluvion</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2020年5月20日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2020/06/08/PHP%E4%BB%8E%E7%BC%96%E8%AF%91%E5%88%B0%E6%89%A7%E8%A1%8C/" title="PHP从编译到执行">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">PHP从编译到执行</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2020/05/12/%E5%88%A9%E7%94%A8%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E8%BF%9B%E8%A1%8CJNDI%E6%B3%A8%E5%85%A5/" title="利用反序列化进行JNDI注入">
                        <span class="hidden-mobile">利用反序列化进行JNDI注入</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
