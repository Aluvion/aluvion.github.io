

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/css/images/bg/favicon.ico">
  <link rel="icon" href="/css/images/bg/favicon.ico">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Aluvion">
  <meta name="keywords" content="">
  
    <meta name="description" content="前言 强化学习，场景来自强网杯2020决赛的一道题。 顺序奇乱，看到什么想到什么就写什么，回过头来估计就看不懂了。">
<meta property="og:type" content="article">
<meta property="og:title" content="chrome浏览器漏洞强化1">
<meta property="og:url" content="http://yoursite.com/2021/04/07/chrome%E6%B5%8F%E8%A7%88%E5%99%A8%E6%BC%8F%E6%B4%9E%E5%BC%BA%E5%8C%961/index.html">
<meta property="og:site_name" content="Twings">
<meta property="og:description" content="前言 强化学习，场景来自强网杯2020决赛的一道题。 顺序奇乱，看到什么想到什么就写什么，回过头来估计就看不懂了。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://yoursite.com/css/images/qwb2020_goo/2021040701.png">
<meta property="og:image" content="http://yoursite.com/css/images/qwb2020_goo/2021040702.png">
<meta property="og:image" content="http://yoursite.com/css/images/qwb2020_goo/2021040703.png">
<meta property="og:image" content="http://yoursite.com/css/images/qwb2020_goo/2021040704.png">
<meta property="og:image" content="http://yoursite.com/css/images/qwb2020_goo/2021040705.png">
<meta property="og:image" content="http://yoursite.com/css/images/qwb2020_goo/2021040706.png">
<meta property="og:image" content="http://yoursite.com/css/images/qwb2020_goo/2021040707.png">
<meta property="og:image" content="http://yoursite.com/css/images/qwb2020_goo/2021040708.png">
<meta property="og:image" content="http://yoursite.com/css/images/qwb2020_goo/2021040709.png">
<meta property="og:image" content="http://yoursite.com/css/images/qwb2020_goo/2021040710.png">
<meta property="og:image" content="http://yoursite.com/css/images/qwb2020_goo/2021040711.png">
<meta property="og:image" content="http://yoursite.com/css/images/qwb2020_goo/2021040712.png">
<meta property="og:image" content="http://yoursite.com/css/images/qwb2020_goo/2021040713.png">
<meta property="og:image" content="http://yoursite.com/css/images/qwb2020_goo/2021040714.png">
<meta property="og:image" content="http://yoursite.com/css/images/qwb2020_goo/2021040715.png">
<meta property="og:image" content="http://yoursite.com/css/images/qwb2020_goo/2021040716.png">
<meta property="og:image" content="http://yoursite.com/css/images/qwb2020_goo/2021040717.png">
<meta property="og:image" content="http://yoursite.com/css/images/qwb2020_goo/2021040718.png">
<meta property="og:image" content="http://yoursite.com/css/images/qwb2020_goo/2021040719.png">
<meta property="og:image" content="http://yoursite.com/css/images/qwb2020_goo/2021040720.png">
<meta property="og:image" content="http://yoursite.com/css/images/qwb2020_goo/2021040721.png">
<meta property="article:published_time" content="2021-04-06T16:12:00.000Z">
<meta property="article:modified_time" content="2022-04-15T13:37:13.168Z">
<meta property="article:author" content="Aluvion">
<meta property="article:tag" content="Web">
<meta property="article:tag" content="二进制">
<meta property="article:tag" content="浏览器">
<meta property="article:tag" content="Chrome">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://yoursite.com/css/images/qwb2020_goo/2021040701.png">
  
  
  
  <title>chrome浏览器漏洞强化1 - Twings</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"yoursite.com","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 7.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Twings&#39; Blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/" target="_self">
                <i class="iconfont icon-link-fill"></i>
                <span>友链</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/css/images/bg/bg5.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="chrome浏览器漏洞强化1"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2021-04-07 00:12" pubdate>
          2021年4月7日 凌晨
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          4.7k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          40 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">chrome浏览器漏洞强化1</h1>
            
            
              <div class="markdown-body">
                
                <h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p> 强化学习，场景来自强网杯2020决赛的一道题。</p>
<p>顺序奇乱，看到什么想到什么就写什么，回过头来估计就看不懂了。</p>
<span id="more"></span>

<hr>
<h3 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h3><p>跟<a href="https://aluvion.gitee.io/2021/03/16/Chrome%E6%B5%8F%E8%A7%88%E5%99%A8%E6%BC%8F%E6%B4%9E%E5%85%A5%E9%97%A8/">上一篇文章</a>差不多，不过这次不切换分支了（记得把diff打上去），期间还遇到一个一个问题：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-regexp">/root/</span>v8<span class="hljs-regexp">/v8/</span>buildtools<span class="hljs-regexp">/linux64/</span>gn: <span class="hljs-regexp">/lib64/</span>libc.so.<span class="hljs-number">6</span>: version `<span class="hljs-type">GLIBC_2</span>.<span class="hljs-number">18</span>&#x27; not found (<span class="hljs-keyword">required</span> by <span class="hljs-regexp">/root/</span>v8<span class="hljs-regexp">/v8/</span>buildtools<span class="hljs-regexp">/linux64/</span>gn)<br></code></pre></td></tr></table></figure>

<p>看起来是Glibc版本过低，更新的时候出了点奇奇怪怪的问题，所以换个Centos8再来一遍（yum install python2就能装上python2.7了），为了编译得快点，顺便换个更高配的主机。</p>
<p>然后就可以开始调试了，先用directory命令把源码目录配置进来。</p>
<h3 id="diff分析"><a href="#diff分析" class="headerlink" title="diff分析"></a>diff分析</h3><p>diff文件如下：</p>
<figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs diff"><span class="hljs-comment">diff --git a/src/compiler/load-elimination.cc b/src/compiler/load-elimination.cc</span><br><span class="hljs-comment">index ff79da8c86..8effdd6e15 100644</span><br><span class="hljs-comment">--- a/src/compiler/load-elimination.cc</span><br><span class="hljs-comment">+++ b/src/compiler/load-elimination.cc</span><br><span class="hljs-meta">@@ -866,8 +866,8 @@</span> Reduction LoadElimination::ReduceTransitionElementsKind(Node* node) &#123;<br>     if (object_maps.contains(ZoneHandleSet&lt;Map&gt;(source_map))) &#123;<br>       object_maps.remove(source_map, zone());<br>       object_maps.insert(target_map, zone());<br><span class="hljs-deletion">-      AliasStateInfo alias_info(state, object, source_map);</span><br><span class="hljs-deletion">-      state = state-&gt;KillMaps(alias_info, zone());</span><br><span class="hljs-addition">+      // AliasStateInfo alias_info(state, object, source_map);</span><br><span class="hljs-addition">+      // state = state-&gt;KillMaps(alias_info, zone());</span><br>       state = state-&gt;SetMaps(object, object_maps, zone());<br>     &#125;<br>   &#125; else &#123;<br><span class="hljs-meta">@@ -892,7 +892,7 @@</span> Reduction LoadElimination::ReduceTransitionAndStoreElement(Node* node) &#123;<br>   if (state-&gt;LookupMaps(object, &amp;object_maps)) &#123;<br>     object_maps.insert(double_map, zone());<br>     object_maps.insert(fast_map, zone());<br><span class="hljs-deletion">-    state = state-&gt;KillMaps(object, zone());</span><br><span class="hljs-addition">+    // state = state-&gt;KillMaps(object, zone());</span><br>     state = state-&gt;SetMaps(object, object_maps, zone());<br>   &#125;<br>   // Kill the elements as well.<br></code></pre></td></tr></table></figure>

<p>diff文件的修改简单来说就是注释掉了两个函数中调用KillMaps的部分。</p>
<h3 id="触发ReduceTransitionElementsKind"><a href="#触发ReduceTransitionElementsKind" class="headerlink" title="触发ReduceTransitionElementsKind"></a>触发ReduceTransitionElementsKind</h3><p>先看看ReduceTransitionElementsKind函数究竟是个什么，往上找找这个函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">switch</span> (node-&gt;<span class="hljs-built_in">opcode</span>()) &#123;<br>    ...<br>    <span class="hljs-keyword">case</span> IrOpcode::kTransitionElementsKind:<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">ReduceTransitionElementsKind</span>(node);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>执行kTransitionElementsKind这个操作码的时候会调用这个函数，再看看这个操作码的名字kTransitionElementsKind，看起来是个用于转换数组成员类型的操作码，给ReduceTransitionElementsKind函数打上断点（需要先用d8运行一个JavaScript脚本后才会加载这个符号进来）然后简单测试一下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">var a = [];<br>a[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>a[<span class="hljs-number">0</span>] = <span class="hljs-number">1.1</span>;<br>a[<span class="hljs-number">0</span>] = &#123;&#125;;<br></code></pre></td></tr></table></figure>

<p>不会触发断点，看起来除了数组类型转换，还需要满足其他条件才行。</p>
<p>继续阅读源码，看看这个操作码所属的类IrOpcode，其中一部分如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">V8_EXPORT_PRIVATE</span> IrOpcode &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-keyword">enum</span> <span class="hljs-title class_">Value</span> &#123;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> DECLARE_OPCODE(x, ...) k##x,</span><br>    <span class="hljs-built_in">ALL_OP_LIST</span>(DECLARE_OPCODE)<br><span class="hljs-meta">#<span class="hljs-keyword">undef</span> DECLARE_OPCODE</span><br>        kLast = <span class="hljs-number">-1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> COUNT_OPCODE(...) +1</span><br>                <span class="hljs-built_in">ALL_OP_LIST</span>(COUNT_OPCODE)<br><span class="hljs-meta">#<span class="hljs-keyword">undef</span> COUNT_OPCODE</span><br>  &#125;;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>看起来是给某个字符串加上个k然后定义操作码的地方，找找TransitionElementsKind：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> SIMPLIFIED_OTHER_OP_LIST(V)     \</span><br><span class="hljs-meta">  ...</span><br>  <span class="hljs-built_in">V</span>(TransitionElementsKind)             \<br>  ...<br></code></pre></td></tr></table></figure>

<p>看起来归属于SIMPLIFIED类操作码，在simplified-operator.cc中能找到生成该操作的函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">const</span> Operator* <span class="hljs-title">SimplifiedOperatorBuilder::TransitionElementsKind</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">    ElementsTransition transition)</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">zone</span>()-&gt;New&lt;Operator1&lt;ElementsTransition&gt;&gt;(  <span class="hljs-comment">// --</span><br>      IrOpcode::kTransitionElementsKind,              <span class="hljs-comment">// opcode</span><br>      Operator::kNoThrow,                             <span class="hljs-comment">// flags</span><br>      <span class="hljs-string">&quot;TransitionElementsKind&quot;</span>,                       <span class="hljs-comment">// name</span><br>      <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>,                               <span class="hljs-comment">// counts</span><br>      transition);                                    <span class="hljs-comment">// parameter</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>可以看到返回类型是Operator，而前面switch的node结构体时相吻合：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">V8_EXPORT_PRIVATE</span> Node <span class="hljs-keyword">final</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  ...<br>  <span class="hljs-function">IrOpcode::Value <span class="hljs-title">opcode</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>    <span class="hljs-built_in">DCHECK_GE</span>(IrOpcode::kLast, op_-&gt;<span class="hljs-built_in">opcode</span>());<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">static_cast</span>&lt;IrOpcode::Value&gt;(op_-&gt;<span class="hljs-built_in">opcode</span>());<br>  &#125;<br>  <br>  ...<br>  <span class="hljs-type">const</span> Operator* op_;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>从TransitionElementsKind函数继续往上找，找到js-native-context-specialization.cc中的ReduceElementAccess函数，再结合前面的ReduceTransitionElementsKind函数，它们似乎都是用于减少某些操作（类型转换、成员访问）次数用的，那就试试用循环将前面的测试代码多跑上很多次：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++">var a;<br><span class="hljs-keyword">for</span> (var i = <span class="hljs-number">0</span>;i &lt; <span class="hljs-number">10000</span>;i++) &#123;<br>   a = [];<br>   a[<span class="hljs-number">0</span>] = <span class="hljs-number">233</span>;<br>   a[<span class="hljs-number">0</span>] = <span class="hljs-number">233.3</span>;<br>   a[<span class="hljs-number">0</span>] = &#123;&#125;;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这次成功触发了ReduceElementAccess函数处的断点，但是没有触发ReduceTransitionElementsKind的断点，调试一下发现似乎是因为没有发生类型转换。</p>
<p>这个时候我们观察一下调用栈：</p>
<p><img src="/css/images/qwb2020_goo/2021040701.png" srcset="/img/loading.gif" lazyload></p>
<p>注意到runtime-complier，运行时编译，也就是JIT，JavaScript的JIT机制会将某一段经常运行的代码（warm）编译成汇编代码以求加快代码的执行速度，而如果这段代码比预计中运行的还要多（hot），JIT就会把这段代码加以优化来再加快执行速度，所以这些reduce函数其实就是JIT对于hot代码的加速处理。</p>
<p>所以我们可以通过打印优化代码的方式，看看JIT将这段代码变成了什么样子，用help参数看看d8程序的参数：</p>
<p><img src="/css/images/qwb2020_goo/2021040702.png" srcset="/img/loading.gif" lazyload></p>
<p>看起来–print-opt-code参数可以打印出优化代码，试一试：</p>
<p><img src="/css/images/qwb2020_goo/2021040703.png" srcset="/img/loading.gif" lazyload></p>
<p>上面是优化后的汇编代码的一部分，可以看到此时生成的数组是一个PACKED_ELEMENTS类型的数组，而这个类型是一个复合类型，里面可以放置整型、浮点、对象等各种类型的成员，所以我们改变它的成员类型时不会发生类型转换。</p>
<p>改一下声明数组的方式：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>;i &lt; <span class="hljs-number">10000</span>;i++) &#123;<br>   a = <span class="hljs-title class_">Array</span>(<span class="hljs-number">0</span>);<br>   a[<span class="hljs-number">0</span>] = <span class="hljs-number">233</span>;<br>   a[<span class="hljs-number">0</span>] = <span class="hljs-number">233.3</span>;<br>   a[<span class="hljs-number">0</span>] = &#123;&#125;;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>此时的汇编代码：</p>
<p><img src="/css/images/qwb2020_goo/2021040704.png" srcset="/img/loading.gif" lazyload></p>
<p>此时的数组类型为PACKED_SMI_ELEMENTS，是一个整型数组，所以我们修改成员类型时会发生类型转换，就会触发ReduceTransitionElementsKind函数处的断点。然后v8就会通过这些代码，将这段经常执行的JavaScript代码编译成汇编代码，下次要执行时就会直接去调用这些汇编代码。从另一个角度来看，如果经常执行的代码来自一个函数，那么通过大量调用它来触发JIT机制并将其编译成汇编代码后，下次调用这个函数也会直接执行这些汇编代码，再如果这些JIT机制的编译代码中存在问题，这些问题导致的后果就会被保存在这些汇编代码中，我们就可以通过写一个函数的方式触发这些问题。</p>
<h3 id="ReduceTransitionElementsKind"><a href="#ReduceTransitionElementsKind" class="headerlink" title="ReduceTransitionElementsKind"></a>ReduceTransitionElementsKind</h3><p>简化一下测试代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>;i &lt; <span class="hljs-number">10000</span>;i++) &#123;<br>    a = <span class="hljs-title class_">Array</span>(<span class="hljs-number">0</span>);<br>    a[<span class="hljs-number">1</span>];<br>    a[<span class="hljs-number">0</span>] = <span class="hljs-number">233.3</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这个函数的流程还是很难理解的，先看看它的参数node：</p>
<p><img src="/css/images/qwb2020_goo/2021040705.png" srcset="/img/loading.gif" lazyload></p>
<p>可以看到这个node的操作类型为TransitionElementsKind，这种node应该是类似AST树节点的一个东西，那它上面应该还挂着操作对象等其他数据。继续往下看代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">ElementsTransition transition = <span class="hljs-built_in">ElementsTransitionOf</span>(node-&gt;<span class="hljs-built_in">op</span>());<br></code></pre></td></tr></table></figure>

<p>ElementsTransitionOf函数看来是从node的op（Operator即操作）中生成了一个用于后续转换的变量：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">ElementsTransition <span class="hljs-type">const</span>&amp; <span class="hljs-title">ElementsTransitionOf</span><span class="hljs-params">(<span class="hljs-type">const</span> Operator* op)</span> </span>&#123;<br>    <span class="hljs-built_in">DCHECK_EQ</span>(IrOpcode::kTransitionElementsKind, op-&gt;<span class="hljs-built_in">opcode</span>());<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">OpParameter</span>&lt;ElementsTransition&gt;(op); <span class="hljs-comment">// OpParameter看起来是在从op中取参</span><br>&#125;<br><br><span class="hljs-comment">// Helper to extract parameters from Operator1&lt;*&gt; operator.</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> T <span class="hljs-type">const</span>&amp; <span class="hljs-title">OpParameter</span><span class="hljs-params">(<span class="hljs-type">const</span> Operator* op)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-type">const</span> Operator1&lt;T, OpEqualTo&lt;T&gt;, OpHash&lt;T&gt;&gt;*&gt;(op) <span class="hljs-comment">// 强制类型转换</span><br>        -&gt;<span class="hljs-built_in">parameter</span>();<br>&#125;<br></code></pre></td></tr></table></figure>

<p>reinterpret_cast是C++中的强制类型转换，在这里他将Operator类型的op转换成了其子类Operator1类型，观察转换后的Operator1对象：</p>
<p><img src="/css/images/qwb2020_goo/2021040706.png" srcset="/img/loading.gif" lazyload></p>
<p>可以看到，此时reinterpret_cast做类之间的类型转换时，只是将一个类用另一个类的方式进行解析而已，它们的地址还是一样的。而Operator1是Operator的子类，所以转换为Operator1对象后，除了有Operator本身的一些成员外，它还会将后面地址的一些数据当作自己的成员，也就是：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">private</span>:<br>    T <span class="hljs-type">const</span> parameter_;<br>    Pred <span class="hljs-type">const</span> pred_;<br>    Hash <span class="hljs-type">const</span> hash_;<br></code></pre></td></tr></table></figure>

<p>这里parameter_成员的T类型就是ElementsTransitionOf函数传入的ElementsTransition类型：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// A descriptor for elements kind transitions.</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ElementsTransition</span> <span class="hljs-keyword">final</span> &#123;<br>    <span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">enum</span> <span class="hljs-title class_">Mode</span> : <span class="hljs-type">uint8_t</span> &#123;<br>        kFastTransition,  <span class="hljs-comment">// simple transition, just updating the map.</span><br>        kSlowTransition   <span class="hljs-comment">// full transition, round-trip to the runtime.</span><br>    &#125;;<br><br>    <span class="hljs-built_in">ElementsTransition</span>(Mode mode, Handle&lt;Map&gt; source, Handle&lt;Map&gt; target)<br>        : <span class="hljs-built_in">mode_</span>(mode), <span class="hljs-built_in">source_</span>(source), <span class="hljs-built_in">target_</span>(target) &#123;&#125;<br><br>    <span class="hljs-function">Mode <span class="hljs-title">mode</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> mode_; &#125;<br>    <span class="hljs-function">Handle&lt;Map&gt; <span class="hljs-title">source</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> source_; &#125;<br>    <span class="hljs-function">Handle&lt;Map&gt; <span class="hljs-title">target</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> target_; &#125;<br><br>    <span class="hljs-keyword">private</span>:<br>    Mode <span class="hljs-type">const</span> mode_;<br>    Handle&lt;Map&gt; <span class="hljs-type">const</span> source_;<br>    Handle&lt;Map&gt; <span class="hljs-type">const</span> target_;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>看起来是个用于描述类型转换的类，包括mode、source、target等三个属性。parameter_的赋值要回到ReduceElementAccess函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++">ElementAccessInfo access_info = access_infos.<span class="hljs-built_in">front</span>();<br><br><span class="hljs-comment">// Perform possible elements kind transitions.</span><br><span class="hljs-function">MapRef <span class="hljs-title">transition_target</span><span class="hljs-params">(broker(),</span></span><br><span class="hljs-params"><span class="hljs-function">                         access_info.lookup_start_object_maps().front())</span></span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> source : access_info.<span class="hljs-built_in">transition_sources</span>()) &#123;<br>    <span class="hljs-built_in">DCHECK_EQ</span>(access_info.<span class="hljs-built_in">lookup_start_object_maps</span>().<span class="hljs-built_in">size</span>(), <span class="hljs-number">1</span>);<br>    <span class="hljs-function">MapRef <span class="hljs-title">transition_source</span><span class="hljs-params">(broker(), source)</span></span>;<br>    effect = <span class="hljs-built_in">graph</span>()-&gt;<span class="hljs-built_in">NewNode</span>(<br>        <span class="hljs-built_in">simplified</span>()-&gt;<span class="hljs-built_in">TransitionElementsKind</span>(<span class="hljs-built_in">ElementsTransition</span>(<br>            <span class="hljs-built_in">IsSimpleMapChangeTransition</span>(transition_source.<span class="hljs-built_in">elements_kind</span>(),<br>                                        transition_target.<span class="hljs-built_in">elements_kind</span>())<br>            ? ElementsTransition::kFastTransition<br>            : ElementsTransition::kSlowTransition,<br>            transition_source.<span class="hljs-built_in">object</span>(), transition_target.<span class="hljs-built_in">object</span>())),<br>        receiver, effect, control);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>access_info是个ElementAccessInfo对象，这个类的注释如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// This class encapsulates all information required to access a certain element.</span><br></code></pre></td></tr></table></figure>

<p>也就是说是个用于访问数组成员的类，打印一下看看（a[0]&#x3D;233.3这一句时触发的断点）：</p>
<p><img src="/css/images/qwb2020_goo/2021040707.png" srcset="/img/loading.gif" lazyload></p>
<p>根据代码我们可以看到，转换的source来自access_info的transition_sources_属性，target来自lookup_start_object_maps_属性。这两个属性都是一个C++数组类型的数据，里面都只有一个成员，之后会包装进transition_souce和transition_target中。</p>
<p>前面提到的parameter_属性的mode就是根据transition_source和transition_target的成员类型决定的，它们的成员类型如下：</p>
<p><img src="/css/images/qwb2020_goo/2021040708.png" srcset="/img/loading.gif" lazyload></p>
<p>很明显就是我们对数组a做的类型转换（从整型到浮点），parameter_属性的source_和target_属性分别来自transition_source和transition_target的object函数，transition_source和transition_target都是MapRef类型的对象，它们的object函数经过调试可以找到定义：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// js-heap-broker.cc</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> DEF_OBJECT_GETTER(T)                                                 \</span><br><span class="hljs-meta">  Handle<span class="hljs-string">&lt;T&gt;</span> T##Ref::object() const &#123;                                         \</span><br><span class="hljs-meta">    return Handle<span class="hljs-string">&lt;T&gt;</span>(reinterpret_cast<span class="hljs-string">&lt;Address*&gt;</span>(data_-&gt;object().address())); \</span><br><span class="hljs-meta">  &#125;</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span>  <span class="hljs-comment">// DEBUG</span></span><br><br><span class="hljs-built_in">HEAP_BROKER_SERIALIZED_OBJECT_LIST</span>(DEF_OBJECT_GETTER)<br><span class="hljs-built_in">HEAP_BROKER_POSSIBLY_BACKGROUND_SERIALIZED_OBJECT_LIST</span>(DEF_OBJECT_GETTER)<br><span class="hljs-built_in">HEAP_BROKER_BACKGROUND_SERIALIZED_OBJECT_LIST</span>(DEF_OBJECT_GETTER)<br><span class="hljs-built_in">HEAP_BROKER_NEVER_SERIALIZED_OBJECT_LIST</span>(DEF_OBJECT_GETTER)<br><span class="hljs-meta">#<span class="hljs-keyword">undef</span> DEF_OBJECT_GETTER</span><br><br><span class="hljs-comment">// heap-refs.h</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> HEAP_BROKER_POSSIBLY_BACKGROUND_SERIALIZED_OBJECT_LIST(V) \</span><br><span class="hljs-meta">  <span class="hljs-comment">/* Subtypes of HeapObject */</span>                                    \</span><br><span class="hljs-meta">  V(BigInt)                                                       \</span><br><span class="hljs-meta">  V(HeapNumber)                                                   \</span><br><span class="hljs-meta">  V(Map)</span><br></code></pre></td></tr></table></figure>

<p>所以调用object()就是连续调用data_-&gt;object().address()，简单来说就是transition_source.data_.object_（其实也是前面的source变量）：</p>
<p><img src="/css/images/qwb2020_goo/2021040709.png" srcset="/img/loading.gif" lazyload></p>
<p>里面是个指针，把transition_source和transition_target的object结果都打印一下看看：</p>
<p><img src="/css/images/qwb2020_goo/2021040710.png" srcset="/img/loading.gif" lazyload></p>
<p>可以看到它们指向两个紧挨在一起的地址单元，很可能它们是指向一个新的指针的指针，再打印一轮看看：</p>
<p><img src="/css/images/qwb2020_goo/2021040711.png" srcset="/img/loading.gif" lazyload></p>
<p>可以看到，它们指向的数据最低位都是1，恰好符合v8中的指针存储方式，用job命令验证一下：</p>
<p><img src="/css/images/qwb2020_goo/2021040712.png" srcset="/img/loading.gif" lazyload></p>
<p>可以看到，这就是代表数组类型的两个Map属性了。</p>
<h3 id="object-maps-contains判断"><a href="#object-maps-contains判断" class="headerlink" title="object_maps.contains判断"></a>object_maps.contains判断</h3><p>要进入被diff修改的代码处还需要满足两个条件，第一个不提，如果我们将代码修改为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++">var a;<br><span class="hljs-keyword">for</span> (var i = <span class="hljs-number">0</span>;i &lt; <span class="hljs-number">10000</span>;i++) &#123;<br>    a = <span class="hljs-built_in">Array</span>(<span class="hljs-number">0</span>);<br>    a[<span class="hljs-number">0</span>] = <span class="hljs-number">233.3</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>第二个条件：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (object_maps.<span class="hljs-built_in">contains</span>(<span class="hljs-built_in">ZoneHandleSet</span>&lt;Map&gt;(source_map)))<br></code></pre></td></tr></table></figure>

<p>就会无法通过。object_maps是一个对象Map属性的Set集合，里面存储了访问过的一些对象的Map属性，所以在进行类型转换之前，需要先访问一下这个数组内的成员，object_maps中才会存有这个数组的Map属性，即这里的source_map变量。</p>
<h3 id="KillMaps"><a href="#KillMaps" class="headerlink" title="KillMaps"></a>KillMaps</h3><p>代码中还能看到一些zone类的使用，其注释如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// The Zone supports very fast allocation of small chunks of</span><br><span class="hljs-comment">// memory. The chunks cannot be deallocated individually, but instead</span><br><span class="hljs-comment">// the Zone supports deallocating all chunks in one fast</span><br><span class="hljs-comment">// operation. The Zone is used to hold temporary data structures like</span><br><span class="hljs-comment">// the abstract syntax tree, which is deallocated after compilation.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// Note: There is no need to initialize the Zone; the first time an</span><br><span class="hljs-comment">// allocation is attempted, a segment of memory will be requested</span><br><span class="hljs-comment">// through the allocator.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// Note: The implementation is inherently not thread safe. Do not use</span><br><span class="hljs-comment">// from multi-threaded code.</span><br></code></pre></td></tr></table></figure>

<p>看起来是用来分配内存的，从开开始看代码下来：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++">Node* <span class="hljs-type">const</span> object = NodeProperties::<span class="hljs-built_in">GetValueInput</span>(node, <span class="hljs-number">0</span>);<br><span class="hljs-function">Handle&lt;Map&gt; <span class="hljs-title">source_map</span><span class="hljs-params">(transition.source())</span></span>;<br><span class="hljs-function">Handle&lt;Map&gt; <span class="hljs-title">target_map</span><span class="hljs-params">(transition.target())</span></span>;<br>Node* <span class="hljs-type">const</span> effect = NodeProperties::<span class="hljs-built_in">GetEffectInput</span>(node);<br>AbstractState <span class="hljs-type">const</span>* state = node_states_.<span class="hljs-built_in">Get</span>(effect);<br></code></pre></td></tr></table></figure>

<p>可以看到，object、effect两个node都来自参数的node（即操作类型为TransitionElementsKind的node），node类的注释如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// A Node is the basic primitive of graphs. Nodes are chained together by</span><br><span class="hljs-comment">// input/use chains but by default otherwise contain only an identifying number</span><br><span class="hljs-comment">// which specific applications of graphs and nodes can use to index auxiliary</span><br><span class="hljs-comment">// out-of-line data, especially transient data.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// In addition Nodes only contain a mutable Operator that may change during</span><br><span class="hljs-comment">// compilation, e.g. during lowering passes. Other information that needs to be</span><br><span class="hljs-comment">// associated with Nodes during compilation must be stored out-of-line indexed</span><br><span class="hljs-comment">// by the Node&#x27;s id.</span><br></code></pre></td></tr></table></figure>

<p>大概就是说节点（node）是图（graph）的基本构成，每个节点有一个用于区分的ID且只有一个操作，节点之间通过input&#x2F;use来连接：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// ---------------------------------------------------------------------------</span><br><span class="hljs-comment">// Input layout.</span><br><span class="hljs-comment">// Inputs are always arranged in order as follows:</span><br><span class="hljs-comment">//     0 [ values, context, frame state, effects, control ] node-&gt;InputCount()</span><br></code></pre></td></tr></table></figure>

<p>可以看到，一共有五种输入（input），这里关注value（大概是该操作需要的操作对象&#x2F;参数）和effect（动作&#x2F;下一步操作）这两种输入，先看看value：</p>
<p><img src="/css/images/qwb2020_goo/2021040713.png" srcset="/img/loading.gif" lazyload></p>
<p>value_in和value_out就相当于进出节点的感觉。可以看到，这是个FinishRegion节点（调试可以发现跟在ReduceElementAccess函数中生成的不太一样，可能后面做了什么处理），代码中有一段关于FinishRegion节点的注释：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// If we previously recorded information about a const store on the given</span><br><span class="hljs-comment">// &#x27;object&#x27;, we might not have done it on the same node; e.g. we might now</span><br><span class="hljs-comment">// identify the object by a FinishRegion node, whereas the initial const</span><br><span class="hljs-comment">// store was performed on the Allocate node. We therefore remove information</span><br><span class="hljs-comment">// on all nodes that must alias with &#x27;object&#x27;.</span><br></code></pre></td></tr></table></figure>

<p>看起来是跟常量存储相关的节点（调试其Value节点是个Allocate节点，再继续可以看到是个NumberConstant节点，里面放了个数16，不知道做什么用的），此外，既然他是TransitionElementsKind操作的Value节点，那它应该是个与我们要进行类型转换的数组a有关的节点。</p>
<p>source_map和target_map就是前面提到过的两个Map属性，再看看effect变量：</p>
<p><img src="/css/images/qwb2020_goo/2021040714.png" srcset="/img/loading.gif" lazyload></p>
<p>是个CheckBounds节点，看起来是用来检查数组边界的，跟这次的主题没什么关系的样子。</p>
<p>然后是state，它从node_states_变量而来，这是个AbstractStateForEffectNodes对象，从名字上看起来是根据Effect节点获取相应的状态（state），其定义如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++">LoadElimination::AbstractState <span class="hljs-type">const</span>*<br>    LoadElimination::AbstractStateForEffectNodes::<span class="hljs-built_in">Get</span>(Node* node) <span class="hljs-type">const</span> &#123;<br>    <span class="hljs-type">size_t</span> <span class="hljs-type">const</span> id = node-&gt;<span class="hljs-built_in">id</span>();<br>    <span class="hljs-keyword">if</span> (id &lt; info_for_node_.<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">return</span> info_for_node_[id];<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>看起来，每个节点都有一个相应的状态，此时获取了TransitionElementsKind节点的Effect节点（CheckBounds）对应的状态，这是一个AbstractState对象，里面有个Print函数可以打印出其中的数据：</p>
<p><img src="/css/images/qwb2020_goo/2021040715.png" srcset="/img/loading.gif" lazyload></p>
<p>Allocate节点应该就是那个与JavaScript中数组a相关的节点，可以看到状态由maps和fields两种成员组成，看起来都跟节点有关，查看它们在源码里的定义可以发现，它们都有一个重要的属性叫做info_for_node_，v8可以根据节点从中取出相关的数据，具体的后面再说。</p>
<p>接下来就看关键的三行代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">AliasStateInfo <span class="hljs-title">alias_info</span><span class="hljs-params">(state, object, source_map)</span></span>;<br>state = state-&gt;<span class="hljs-built_in">KillMaps</span>(alias_info, <span class="hljs-built_in">zone</span>());<br>state = state-&gt;<span class="hljs-built_in">SetMaps</span>(object, object_maps, <span class="hljs-built_in">zone</span>());<br></code></pre></td></tr></table></figure>

<p>使用状态、对象和转换前Map属性制作了一个alias_info变量，看其名字可能是用于查找同名&#x2F;同个节点的，具体用处还要往后看。此外我们还可以看到，在JIT中代表一个对象的节点跟其Map属性是分割开的，那么久可能存在一个情况，读写该对象时使用的类型不是放在该对象首个地址单元处的Map属性，而是保存在状态某个地方与该对象节点相关联的Map属性。</p>
<p>再看看KillMaps函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++">LoadElimination::AbstractState <span class="hljs-type">const</span>* LoadElimination::AbstractState::<span class="hljs-built_in">KillMaps</span>(<br>    <span class="hljs-type">const</span> AliasStateInfo&amp; alias_info, Zone* zone) <span class="hljs-type">const</span> &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>-&gt;maps_) &#123;<br>        AbstractMaps <span class="hljs-type">const</span>* that_maps = <span class="hljs-keyword">this</span>-&gt;maps_-&gt;<span class="hljs-built_in">Kill</span>(alias_info, zone);<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>-&gt;maps_ != that_maps) &#123;<br>            AbstractState* that = zone-&gt;<span class="hljs-built_in">New</span>&lt;AbstractState&gt;(*<span class="hljs-keyword">this</span>);<br>            that-&gt;maps_ = that_maps;<br>            <span class="hljs-keyword">return</span> that;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>基本上可以认为就是调用了this-&gt;maps_-&gt;Kill，不然就跟没调用没什么区别，maps_属性是个AbstractMaps对象，其定义如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// Abstract state to approximate the current map of an object along the</span><br><span class="hljs-comment">// effect paths through the graph.</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractMaps</span> <span class="hljs-keyword">final</span> : <span class="hljs-keyword">public</span> ZoneObject &#123;<br>    <span class="hljs-keyword">public</span>:<br>    ...<br><br>    <span class="hljs-keyword">private</span>:<br>    ZoneMap&lt;Node*, ZoneHandleSet&lt;Map&gt;&gt; info_for_node_;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>从注释来看，似乎是用于描述某个对象的Map属性的？可以看到里面只有一个属性info_for_node_，其是一个Map类型的对象，键为node值为Set，值的类型看起来很眼熟（ReduceTransitionElementsKind函数中的object_maps变量），我们回去看看：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">ZoneHandleSet&lt;Map&gt; object_maps;<br><span class="hljs-keyword">if</span> (state-&gt;<span class="hljs-built_in">LookupMaps</span>(object, &amp;object_maps)) &#123;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure>

<p>看起来它是从state中获得的，再跟一跟：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">bool</span> LoadElimination::AbstractState::<span class="hljs-built_in">LookupMaps</span>(<br>    Node* object, ZoneHandleSet&lt;Map&gt;* object_map) <span class="hljs-type">const</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt;maps_ &amp;&amp; <span class="hljs-keyword">this</span>-&gt;maps_-&gt;<span class="hljs-built_in">Lookup</span>(object, object_map);<br>&#125;<br><br><span class="hljs-type">bool</span> LoadElimination::AbstractMaps::<span class="hljs-built_in">Lookup</span>(<br>    Node* object, ZoneHandleSet&lt;Map&gt;* object_maps) <span class="hljs-type">const</span> &#123;<br>    <span class="hljs-keyword">auto</span> it = info_for_node_.<span class="hljs-built_in">find</span>(<span class="hljs-built_in">ResolveRenames</span>(object));<br>    <span class="hljs-keyword">if</span> (it == info_for_node_.<span class="hljs-built_in">end</span>()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    *object_maps = it-&gt;second;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>可以看到，它最后就是来自state的maps_属性的info_for_node_属性，那么就是说，在JIT代码中，一个对象由一个节点表示，状态中保存着与该节点相关联的Map属性，需要使用时可以根据节点取出。</p>
<h3 id="Kill"><a href="#Kill" class="headerlink" title="Kill"></a>Kill</h3><p>回到KillMaps，进入Kill函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++">LoadElimination::AbstractMaps <span class="hljs-type">const</span>* LoadElimination::AbstractMaps::<span class="hljs-built_in">Kill</span>(<br>    <span class="hljs-type">const</span> AliasStateInfo&amp; alias_info, Zone* zone) <span class="hljs-type">const</span> &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> pair : <span class="hljs-keyword">this</span>-&gt;info_for_node_) &#123;<br>        <span class="hljs-keyword">if</span> (alias_info.<span class="hljs-built_in">MayAlias</span>(pair.first)) &#123;<br>            AbstractMaps* that = zone-&gt;<span class="hljs-built_in">New</span>&lt;AbstractMaps&gt;(zone);<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> pair : <span class="hljs-keyword">this</span>-&gt;info_for_node_) &#123;<br>                <span class="hljs-keyword">if</span> (!alias_info.<span class="hljs-built_in">MayAlias</span>(pair.first)) that-&gt;info_for_node_.<span class="hljs-built_in">insert</span>(pair);<br>            &#125;<br>            <span class="hljs-keyword">return</span> that;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>遍历了info_for_node_属性这个Map，pair.first代表键即节点，这里的关键在于MayAlias函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">bool</span> LoadElimination::AliasStateInfo::<span class="hljs-built_in">MayAlias</span>(Node* other) <span class="hljs-type">const</span> &#123;<br>    <span class="hljs-comment">// If &#123;object&#125; is being initialized right here (indicated by &#123;object&#125; being</span><br>    <span class="hljs-comment">// an Allocate node instead of a FinishRegion node), we know that &#123;other&#125;</span><br>    <span class="hljs-comment">// can only alias with &#123;object&#125; if they refer to exactly the same node.</span><br>    <span class="hljs-keyword">if</span> (object_-&gt;<span class="hljs-built_in">opcode</span>() == IrOpcode::kAllocate) &#123;<br>        <span class="hljs-keyword">return</span> object_ == other;<br>    &#125;<br>    <span class="hljs-comment">// Decide aliasing based on the node kinds.</span><br>    <span class="hljs-keyword">if</span> (!compiler::<span class="hljs-built_in">MayAlias</span>(object_, other)) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-comment">// Decide aliasing based on maps (if available).</span><br>    Handle&lt;Map&gt; map;<br>    <span class="hljs-keyword">if</span> (map_.<span class="hljs-built_in">ToHandle</span>(&amp;map)) &#123;<br>        ZoneHandleSet&lt;Map&gt; other_maps;<br>        <span class="hljs-keyword">if</span> (state_-&gt;<span class="hljs-built_in">LookupMaps</span>(other, &amp;other_maps) &amp;&amp; other_maps.<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">if</span> (map.<span class="hljs-built_in">address</span>() != other_maps.<span class="hljs-built_in">at</span>(<span class="hljs-number">0</span>).<span class="hljs-built_in">address</span>()) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>用于判断两个节点是否是同一个，综合Kill和MayAlias函数起来看，意思就是，如果一个状态中有两个或更多节点关联着同一个Map属性，就会新建一个新的AbstractMaps对象（也就是跟状态中的maps_属性相同类型），然后将其他与此Map属性无关的节点-属性对应放进这个新的AbstractMaps对象中，简单来说就是把跟这个要被转换的Map属性从状态里面删掉了，最后将新的AbstractMaps对象返回。</p>
<p>再结合起KillMaps函数，如果Kill函数返回了一个新的AbstractMaps对象，就会用其包装一个新的状态再返回。</p>
<p>最后总结，KillMaps函数的作用就是将这个要被转换的Map属性从状态里面删掉，setMaps的作用就是将新的Map属性放入状态中并与此节点再次关联起来，这样就避免了当一个状态中有两个或更多节点关联着同一个Map属性时，前面一个节点发生了类型转换修改了其关联着的Map属性，后一个&#x2F;一些节点还保留着旧的Map属性（这样不同节点就会以不同类型访问同个数组对象，造成类型混淆）。而题目中注释掉了这行代码，就会导致这个要被转换的Map属性被保留了下来，而setMaps只会修改该发生类型转换节点的Map属性，而其他节点没有修改，导致一个类型混淆漏洞。</p>
<h3 id="类型混淆"><a href="#类型混淆" class="headerlink" title="类型混淆"></a>类型混淆</h3><p>要制造”一个状态中有两个或更多节点关联着同一个Map属性”这个情况，用函数传参来做是最方便的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">optCode</span>(<span class="hljs-params">a, b</span>) &#123;<br>    a[<span class="hljs-number">0</span>];<br>    a[<span class="hljs-number">0</span>] = <span class="hljs-number">1.1</span>;<br>    b[<span class="hljs-number">0</span>];<br>    b[<span class="hljs-number">0</span>] = &#123;&#125;;<br>&#125;<br><br><span class="hljs-keyword">var</span> a;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>;i &lt; <span class="hljs-number">10000</span>;i++) &#123;<br>    a = <span class="hljs-title class_">Array</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-title function_">optCode</span>(a, a);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>第一次类型转换的setMaps前：</p>
<p><img src="/css/images/qwb2020_goo/2021040716.png" srcset="/img/loading.gif" lazyload></p>
<p>第一次类型转换的setMaps后：</p>
<p><img src="/css/images/qwb2020_goo/2021040717.png" srcset="/img/loading.gif" lazyload></p>
<p>第二次类型转换的setMaps前：</p>
<p><img src="/css/images/qwb2020_goo/2021040718.png" srcset="/img/loading.gif" lazyload></p>
<p>第二次类型转换的setMaps后：</p>
<p><img src="/css/images/qwb2020_goo/2021040719.png" srcset="/img/loading.gif" lazyload></p>
<p>可以看到，两个节点相关联的Map属性已经产生了区别，a把它当作浮点数组，b把它当作对象数组，而它实际上已经是个对象数组，这样一来类型混淆就产生了。经过测试我们发现，这种Map属性不一致（对象数组和浮点数组）的情况下函数返回之后a会是一个对象数组，所以我们可以让a把它当作对象数组，b把它当作浮点数组，这样我们就可以通过写b将一个浮点数写入进去，后面访问的时候就会把这个浮点数当作一个指针。</p>
<p>实际上这样利用还是无法成功，因为函数代码比较简单，所以JIT在编译阶段可以获得的信息比较充分，类型判断简单，我们可以通过添加条件判断的方式绕过：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">optCode</span>(<span class="hljs-params">a, b, f1, f2</span>) &#123;<br>    a[<span class="hljs-number">0</span>];<br>    b[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">if</span> (f1) &#123;<br>        a[<span class="hljs-number">0</span>] = &#123;&#125;;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (f2) &#123;<br>        b[<span class="hljs-number">0</span>] = <span class="hljs-number">1.1</span>;<br>    &#125;<br>    <br>&#125;<br><br><span class="hljs-keyword">var</span> a;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>;i &lt; <span class="hljs-number">10000</span>;i++) &#123;<br>    a = <span class="hljs-title class_">Array</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-title function_">optCode</span>(a, a, <span class="hljs-literal">true</span>, <span class="hljs-literal">false</span>);<br>    a = <span class="hljs-title class_">Array</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-title function_">optCode</span>(a, a, <span class="hljs-literal">false</span>, <span class="hljs-literal">true</span>);<br>&#125;<br><br>a = <span class="hljs-title class_">Array</span>(<span class="hljs-number">0</span>);<br><span class="hljs-title function_">optCode</span>(a, a, <span class="hljs-literal">true</span>, <span class="hljs-literal">true</span>);<br>%<span class="hljs-title class_">DebugPrint</span>(a);<br>%<span class="hljs-title class_">SystemBreak</span>();<br><span class="hljs-title function_">print</span>(a[<span class="hljs-number">0</span>]);<br></code></pre></td></tr></table></figure>

<p>打印出来的数组a：</p>
<p><img src="/css/images/qwb2020_goo/2021040720.png" srcset="/img/loading.gif" lazyload></p>
<p>其element属性如下：</p>
<p><img src="/css/images/qwb2020_goo/2021040721.png" srcset="/img/loading.gif" lazyload></p>
<p>可以看到，写入的浮点数1.1已经被当做了一个指针。后面的做法就是利用v8的pointer compression机制，爆破&#x2F;调试获得低32位地址再进行利用了，太麻烦就不提了。</p>
<hr>
<h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="https://www.anquanke.com/post/id/224195">writeup</a></p>
<p><a href="https://mem2019.github.io/jekyll/update/2020/09/19/QWB-GooExec.html">writeup2</a></p>
<p><a href="https://segmentfault.com/a/1190000023193375">JavaScript数组优化</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/25669120/">JIT</a></p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/Web/" class="print-no-link">#Web</a>
      
        <a href="/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6/" class="print-no-link">#二进制</a>
      
        <a href="/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/" class="print-no-link">#浏览器</a>
      
        <a href="/tags/Chrome/" class="print-no-link">#Chrome</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>chrome浏览器漏洞强化1</div>
      <div>http://yoursite.com/2021/04/07/chrome浏览器漏洞强化1/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Aluvion</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2021年4月7日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2021/04/20/chrome%E6%B5%8F%E8%A7%88%E5%99%A8%E6%BC%8F%E6%B4%9E%E5%BC%BA%E5%8C%962-CVE-2016-5168/" title="chrome浏览器漏洞强化2-CVE-2016-5168">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">chrome浏览器漏洞强化2-CVE-2016-5168</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2021/03/16/Chrome%E6%B5%8F%E8%A7%88%E5%99%A8%E6%BC%8F%E6%B4%9E%E5%85%A5%E9%97%A8/" title="Chrome浏览器漏洞入门">
                        <span class="hidden-mobile">Chrome浏览器漏洞入门</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
